package de.labathome;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.Test;

/**
 * The purpose of this test class is to check the full API of BinaryTimeseries
 * for consistency. The test code can be automagically generated by running the
 * {@code main} method of this class.
 * 
 * @author Jonathan Schilling (jonathan.schilling@mail.de)
 * @version 1.0.0 first published version
 */
public class ApiTests {

	/**
	 * Generate all test methods in this class and print the source code to the
	 * command line.
	 * 
	 * @param args ignored
	 */
	public static void main(String[] args) {

		final byte[] time_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_DOUBLE
		};

		final byte[] scaling_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_NONE,
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};

		final byte[] data_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};

		final int[] data_sizes = new int[] {
				Byte.BYTES,
				Short.BYTES,
				Integer.BYTES,
				Long.BYTES,
				Float.BYTES,
				Double.BYTES };

		final Map<Byte, String> javaName = new HashMap<>();
		javaName.put(BinaryTimeseries.DTYPE_NONE, "null");
		javaName.put(BinaryTimeseries.DTYPE_BYTE, "byte");
		javaName.put(BinaryTimeseries.DTYPE_SHORT, "short");
		javaName.put(BinaryTimeseries.DTYPE_INT, "int");
		javaName.put(BinaryTimeseries.DTYPE_LONG, "long");
		javaName.put(BinaryTimeseries.DTYPE_FLOAT, "float");
		javaName.put(BinaryTimeseries.DTYPE_DOUBLE, "double");

		for (int time_dtype_idx = 0; time_dtype_idx < time_dtypes.length; ++time_dtype_idx) {
			final byte time_dtype = time_dtypes[time_dtype_idx];
			final String tT = BinaryTimeseries.dtypeStr(time_dtype);
			String jtT = javaName.get(time_dtype);

			for (int scaling_dtype_idx = 0; scaling_dtype_idx < scaling_dtypes.length; ++scaling_dtype_idx) {
				final byte scaling_dtype = scaling_dtypes[scaling_dtype_idx];
				final String tS = BinaryTimeseries.dtypeStr(scaling_dtype);
				String jtS = javaName.get(scaling_dtype);

				for (int data_dtype_idx = 0; data_dtype_idx < data_dtypes.length; ++data_dtype_idx) {
					final byte data_dtype = data_dtypes[data_dtype_idx];
					final String tD = BinaryTimeseries.dtypeStr(data_dtype);
					String jtD = javaName.get(data_dtype);
					final int data_size = data_sizes[data_dtype_idx];

					final String testId = tT + "_" + tS + "_" + tD;
					System.out.println("	// " + testId);

					final String numSamplesStr = "10";
					final int numSamples = Integer.parseInt(numSamplesStr);

					final String t0Str = "13.0";
					final double t0 = Double.parseDouble(t0Str);
					final long t0_L = (long) t0;
					final double t0_D = (double) t0;

					final String dtStr = "37.0";
					final double dt = Double.parseDouble(dtStr);
					final long dt_L = (long) dt;
					final double dt_D = (double) dt;

					final String scalingOffsetStr = "1.2";
					final double scalingOffset = Double.parseDouble(scalingOffsetStr);
					final byte scalingOffset_B = (byte) scalingOffset;
					final short scalingOffset_S = (short) scalingOffset;
					final int scalingOffset_I = (int) scalingOffset;
					final long scalingOffset_L = (long) scalingOffset;
					final float scalingOffset_F = (float) scalingOffset;
					final double scalingOffset_D = (double) scalingOffset;

					final String scalingFactorStr = "24.3";
					final double scalingFactor = Double.parseDouble(scalingFactorStr);
					final byte scalingFactor_B = (byte) scalingFactor;
					final short scalingFactor_S = (short) scalingFactor;
					final int scalingFactor_I = (int) scalingFactor;
					final long scalingFactor_L = (long) scalingFactor;
					final float scalingFactor_F = (float) scalingFactor;
					final double scalingFactor_D = (double) scalingFactor;

					// time series:
					// idx |  time | value
					//  0  |  13.0 |   1.2
					//  1  |  50.0 |  25.5
					//  2  |  87.0 |  49.8
					//  3  | 124.0 |  74.1
					//  4  | 161.0 |  98.4
					//  5  | 198.0 | 122.7
					//  6  | 235.0 | 147.0
					//  7  | 272.0 | 171.3
					//  8  | 309.0 | 195.6
					//  9  | 346.0 | 219.9

					final int numSamplesSubset = 5;
					final int sourceOffset = 2;
					final int targetOffset = 0;

					final String t_lStr = "80.0"; // => firstIndexInside = 2
					final String t_uStr = "300.0"; // => lastIndexInside = 7

					// compute file size from reserved number of header bytes, sample size and
					// number of samples
					final int filesize = 64 + data_size * numSamples;

					final byte[] binaryTimeseries = new byte[filesize];

					// check static routines
					if (scaling_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per time type

						// buildTimebase
						System.out.println("	@Test\n" +
								"	public void testBuiltTimebase_"+tT+"() {\n" +
								"		final int numSamples = "+numSamplesStr+";\n" +
								"		final "+jtT+" t0_"+tT+" = ("+jtT+") "+t0Str+";\n" +
								"		final "+jtT+" dt_"+tT+" = ("+jtT+") "+dtStr+";\n" +
								"		final int numSamplesSubset = "+numSamplesSubset+";\n" +
								"		final int sourceOffset = "+sourceOffset+";\n" +
								"		final int targetOffset = "+targetOffset+";\n" +
								"		\n" +
								"		// 'manually' build reference time stamps\n" +
								"		final "+jtT+"[] timebase = new "+jtT+"[numSamples];\n" +
								"		for (int i=0; i<numSamples; ++i) {\n" +
								"			timebase[i] = t0_"+tT+" + i*dt_"+tT+";\n" +
								"		}\n" +
								"		final "+jtT+"[] timebase_subset = new "+jtT+"[numSamplesSubset];\n" +
								"		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);\n" +
								"		\n" +
								"		// no sourceOffset and targetOffset given\n" +
								"		final "+jtT+"[] targetTimebase = new "+jtT+"[numSamples];\n" +
								"		BinaryTimeseries.buildTimebase(targetTimebase, t0_"+tT+", dt_"+tT+");\n" +
								"		assertArrayEquals(timebase, targetTimebase);\n" +
								"		\n" +
								"		// sourceOffset and targetOffset are given\n" +
								"		final "+jtT+"[] targetTimebase_subset = new "+jtT+"[numSamplesSubset];\n" +
								"		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_"+tT+", dt_"+tT+");\n" +
								"		assertArrayEquals(timebase_subset, targetTimebase_subset);\n" +
								"	}\n");

						// testFirstIndexInside
						System.out.println("	@Test\n" +
								"	public void testFirstIndexInside_"+tT+"() {\n" +
								"		final "+jtT+" t0_"+tT+"  = ("+jtT+") "+t0Str+";\n" +
								"		final "+jtT+" dt_"+tT+"  = ("+jtT+") "+dtStr+";\n" +
								"		final "+jtT+" t_l_"+tT+" = ("+jtT+") "+t_lStr+";\n" +
								"		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_"+tT+", dt_"+tT+", t_l_"+tT+"));\n" +
								"	}\n");

						// testLastIndexInside
						System.out.println("	@Test\n" +
								"	public void testLastIndexInside_"+tT+"() {\n" +
								"		final "+jtT+" t0_"+tT+"  = ("+jtT+") "+t0Str+";\n" +
								"		final "+jtT+" dt_"+tT+"  = ("+jtT+") "+dtStr+";\n" +
								"		final "+jtT+" t_u_"+tT+" = ("+jtT+") "+t_uStr+";\n" +
								"		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_"+tT+", dt_"+tT+", t_u_"+tT+"));\n" +
								"	}\n");
					}

					if (time_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per scaling type

					}

					if (time_dtype_idx == 0 && scaling_dtype_idx == 0) {
						// these need to be executed only once per data type

						// fileOffset
						System.out.println("	@Test\n" +
								"	public void testFileOffset_"+tD+"() {\n" +
								"		assertEquals("+filesize+", BinaryTimeseries.fileOffset("+data_size+", "+numSamplesStr+"));\n" +
								"	}\n");
					}

					// code for testing the API write and read methods
					String writeTestCode = "	@Test\n" +
							"	public void testReadWrite_"+testId+"() {\n";

					// 'manually' build a BinaryTimeseries
					final ByteBuffer referenceTarget = ByteBuffer.wrap(binaryTimeseries);
					// assertEquals(0, referenceTarget.position());
					// endianess check short
					referenceTarget.putShort((short) 1);
					// assertEquals(2, referenceTarget.position());
					// dtype of time
					referenceTarget.put(time_dtype);
					// assertEquals(3, referenceTarget.position());

					// t0
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(t0_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(t0_D);
					}
					// assertEquals(11, referenceTarget.position());

					writeTestCode += "		final "+jtT+" t0_"+tT+" = ("+jtT+") "+t0Str+";\n";

					// dt
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(dt_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(dt_D);
					}
					// assertEquals(19, referenceTarget.position());

					writeTestCode += "		final "+jtT+" dt_"+tT+" = ("+jtT+") "+dtStr+";\n";

					// scaling dtype
					referenceTarget.put(scaling_dtype);
					// assertEquals(20, referenceTarget.position());

					// scaling offset
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else {
						if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
							referenceTarget.put(scalingOffset_B);
							referenceTarget.put(new byte[8 - Byte.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
							referenceTarget.putShort(scalingOffset_S);
							referenceTarget.put(new byte[8 - Short.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
							referenceTarget.putInt(scalingOffset_I);
							referenceTarget.put(new byte[8 - Integer.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
							referenceTarget.putLong(scalingOffset_L);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
							referenceTarget.putFloat(scalingOffset_F);
							referenceTarget.put(new byte[8 - Float.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
							referenceTarget.putDouble(scalingOffset_D);
						}
						writeTestCode += "		final "+jtS+" scalingOffset_"+tS+" = ("+jtS+") "+scalingOffsetStr+";\n";
					}
					// assertEquals(28, referenceTarget.position());

					// scaling factor
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else {
						if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
							referenceTarget.put(scalingFactor_B);
							referenceTarget.put(new byte[8 - Byte.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
							referenceTarget.putShort(scalingFactor_S);
							referenceTarget.put(new byte[8 - Short.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
							referenceTarget.putInt(scalingFactor_I);
							referenceTarget.put(new byte[8 - Integer.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
							referenceTarget.putLong(scalingFactor_L);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
							referenceTarget.putFloat(scalingFactor_F);
							referenceTarget.put(new byte[8 - Float.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
							referenceTarget.putDouble(scalingFactor_D);
						}
						writeTestCode += "		final "+jtS+" scalingFactor_"+tS+" = ("+jtS+") "+scalingFactorStr+";\n";
					}
					// assertEquals(36, referenceTarget.position());

					// reserved dummy space
					referenceTarget.put(new byte[23]);
					// assertEquals(59, referenceTarget.position());

					// type of raw data
					referenceTarget.put(data_dtype);
					// assertEquals(60, referenceTarget.position());

					// number of samples
					referenceTarget.putInt(numSamples);
					// assertEquals(64, referenceTarget.position());

					writeTestCode += "		final int numSamples = "+numSamplesStr+";\n";

					// actual data
					if (data_dtype == BinaryTimeseries.DTYPE_BYTE) {
						byte sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (byte) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (byte) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (byte) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (byte) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (byte) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (byte) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (byte) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.put(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_SHORT) {
						short sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (short) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (short) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (short) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (short) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (short) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (short) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (short) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putShort(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_INT) {
						int sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (int) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (int) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (int) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (int) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (int) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (int) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (int) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putInt(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_LONG) {
						long sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (long) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (long) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (long) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (long) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (long) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (long) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (long) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putLong(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						float sample = (float) 0.0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (float) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (float) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (float) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (float) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (float) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (float) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (float) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putFloat(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						double sample = 0.0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (double) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (double) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (double) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (double) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (double) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (double) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (double) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putDouble(sample);
						}
					}
					// assertEquals(filesize, referenceTarget.position());

					writeTestCode += "		final "+jtD+"[] values = new "+jtD+"[numSamples];\n" +
							"		for (int i=0; i<numSamples; ++i) {\n";
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "			values[i] = ("+jtD+") i;\n";
					} else {
						writeTestCode += "			values[i] = ("+jtD+") (scalingOffset_"+tS+" + i*scalingFactor_"+tS+");\n";
					}
					writeTestCode += "		}\n" +
							"		//writing\n" +
							"		int fileSize = BinaryTimeseries.fileOffset("+data_size+", numSamples);\n" +
							"		final byte[] targetArr = new byte[fileSize];\n" +
							"		final ByteBuffer target = ByteBuffer.wrap(targetArr);\n" +
							"		assertEquals(0, target.position());\n" +
							"		BinaryTimeseries.writeEndianessCheckValue(target);\n" +
							"		assertEquals(2, target.position());\n" +
							"		BinaryTimeseries.writeTimebase(target, t0_"+tT+", dt_"+tT+");\n" +
							"		assertEquals(19, target.position());\n";

					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "		BinaryTimeseries.writeScalingDisabled(target);\n";
					} else {
						writeTestCode += "		BinaryTimeseries.writeScaling(target, scalingOffset_"+tS+", scalingFactor_"+tS+");\n";
					}
					writeTestCode += "		assertEquals(36, target.position());\n";

					writeTestCode += "		BinaryTimeseries.writeReservedDummy(target);\n" +
							"		assertEquals(59, target.position());\n" +
							"		BinaryTimeseries.writeData(target, values);\n" +
							"		assertEquals(fileSize, target.position());\n";

					// generate textual representation of byte array containing the reference
					// BinaryTimeseries
					String btsDef = "final byte[] referenceBTS_"+testId+" = new byte[] {\n	";
					for (int i = 0; i < filesize - 1; ++i) {
						if ((i + 1) % 8 == 0) {
							btsDef += String.format("(byte) 0x%02X,\n\t", binaryTimeseries[i]);
						} else {
							btsDef += String.format("(byte) 0x%02X, ", binaryTimeseries[i]);
						}
					}
					btsDef += String.format("(byte) 0x%02X };", binaryTimeseries[filesize - 1]);

					// adjust indentation
					writeTestCode += "		" + btsDef.replace("\t", "\t\t\t") + "\n";

					// finally actually check the array contents
					writeTestCode += "		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";

					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						// rewind and re-check using write() without scaling
						writeTestCode += "		target.position(0);\n" +
								"		BinaryTimeseries.write(target, t0_"+tT+", dt_"+tT+", values);\n" +
								"		assertEquals(fileSize, target.position());\n" +
								"		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";
					} else {
						// rewind and re-check using write() with scaling
						writeTestCode += "		target.position(0);\n" +
								"		BinaryTimeseries.write(target, t0_"+tT+", dt_"+tT+", values, scalingOffset_"+tS+", scalingFactor_"+tS+");\n" +
								"		assertEquals(fileSize, target.position());\n" +
								"		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";
					}

					// now that the writing routines are verified, check the reading routines

					writeTestCode += "		// reading\n"
							+ "		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_" + testId + ");\n"
							+ "		assertEquals(0, source.position());\n"
							+ "		assertEquals(true, BinaryTimeseries.readEndianessOk(source));\n"
							+ "		assertEquals(2, source.position());\n" + "		assertEquals(" + time_dtype
							+ ", BinaryTimeseries.readTimeType(source));\n"
							+ "		assertEquals(3, source.position());\n" + "		assertEquals(t0_" + tT
							+ ", BinaryTimeseries.readTimeT0_" + jtT + "(source));\n"
							+ "		assertEquals(11, source.position());\n" + "		assertEquals(dt_" + tT
							+ ", BinaryTimeseries.readTimeDt_" + jtT + "(source));\n"
							+ "		assertEquals(19, source.position());\n" + "		assertEquals(" + scaling_dtype
							+ ", BinaryTimeseries.readScalingType(source));\n"
							+ "		assertEquals(20, source.position());\n";
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "		BinaryTimeseries.readScalingDisabled(source);\n";
					} else {
						writeTestCode += "		assertEquals(scalingOffset_" + tS
								+ ", BinaryTimeseries.readScalingOffset_" + jtS + "(source));\n"
								+ "		assertEquals(28, source.position());\n" + "		assertEquals(scalingFactor_"
								+ tS + ", BinaryTimeseries.readScalingFactor_" + jtS + "(source));\n"
								+ "		assertEquals(36, source.position());\n";
					}
					writeTestCode += "		assertEquals(36, source.position());\n"
							+ "		BinaryTimeseries.readReservedDummy(source);\n"
							+ "		assertEquals(59, source.position());\n" + "		assertEquals(" + data_dtype
							+ ", BinaryTimeseries.readDataType(source));\n"
							+ "		assertEquals(60, source.position());\n"
							+ "		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));\n"
							+ "		assertEquals(64, source.position());\n" + "		final " + jtD + "[] rawData = new "
							+ jtD + "[numSamples];\n"
							+ "		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(values, rawData);\n";

					// test reading of data into a given array type --> readData_byte...
					writeTestCode += "		// read and scale into given primitive array\n"
							+ "		final   byte[] referenceData_byte   = new   byte[numSamples];\n"
							+ "		final  short[] referenceData_short  = new  short[numSamples];\n"
							+ "		final    int[] referenceData_int    = new    int[numSamples];\n"
							+ "		final   long[] referenceData_long   = new   long[numSamples];\n"
							+ "		final  float[] referenceData_float  = new  float[numSamples];\n"
							+ "		final double[] referenceData_double = new double[numSamples];\n"
							+ "		for (int i=0; i<numSamples; ++i) {\n";
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "			referenceData_byte  [i] = (byte  )i;\n"
								+ "			referenceData_short [i] = (short )i;\n"
								+ "			referenceData_int   [i] = (int   )i;\n"
								+ "			referenceData_long  [i] = (long  )i;\n"
								+ "			referenceData_float [i] = (float )i;\n"
								+ "			referenceData_double[i] = (double)i;\n";
					} else {
						writeTestCode += "			final " + jtD + " referenceValue = (" + jtD + ") (scalingOffset_"
								+ tS + " + i*scalingFactor_" + tS + ");\n"
								+ "			referenceData_byte  [i] = (byte  )(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n"
								+ "			referenceData_short [i] = (short )(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n"
								+ "			referenceData_int   [i] = (int   )(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n"
								+ "			referenceData_long  [i] = (long  )(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n"
								+ "			referenceData_float [i] = (float )(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n"
								+ "			referenceData_double[i] = (double)(scalingOffset_" + tS
								+ " + referenceValue*scalingFactor_" + tS + ");\n";
					}
					writeTestCode += "		}\n" + "		source.position(19);\n"
							+ "		final byte[] data_byte = BinaryTimeseries.readData_byte(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_byte, data_byte);\n"
							+ "		source.position(19);\n"
							+ "		final short[] data_short = BinaryTimeseries.readData_short(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_short, data_short);\n"
							+ "		source.position(19);\n"
							+ "		final int[] data_int = BinaryTimeseries.readData_int(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_int, data_int);\n" + "		source.position(19);\n"
							+ "		final long[] data_long = BinaryTimeseries.readData_long(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_long, data_long);\n"
							+ "		source.position(19);\n"
							+ "		final float[] data_float = BinaryTimeseries.readData_float(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_float, data_float);\n"
							+ "		source.position(19);\n"
							+ "		final double[] data_double = BinaryTimeseries.readData_double(source);\n"
							+ "		assertEquals(fileSize, source.position());\n"
							+ "		assertArrayEquals(referenceData_double, data_double);\n";

					writeTestCode += "	}\n";
					System.out.println(writeTestCode);
				}
			}

		}
	}

	/**
	 * Test that the dtypeStr() method works as expected.
	 */
	@Test
	public void testDtypes() {
		assertEquals("N", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_NONE));
		assertEquals("B", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_BYTE));
		assertEquals("S", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_SHORT));
		assertEquals("I", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_INT));
		assertEquals("L", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_LONG));
		assertEquals("F", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_FLOAT));
		assertEquals("D", BinaryTimeseries.dtypeStr(BinaryTimeseries.DTYPE_DOUBLE));
		assertEquals("?", BinaryTimeseries.dtypeStr((byte) -1));

		assertEquals(false, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_NONE));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_BYTE));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_SHORT));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_INT));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_LONG));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_FLOAT));
		assertEquals(true, BinaryTimeseries.hasScaling(BinaryTimeseries.DTYPE_DOUBLE));
	}

	/**
	 * Test the header data explanation method.
	 */
	@Test
	public void testExplainHeader() {
		String explanation = "";

		byte[] header = null;
		explanation = BinaryTimeseries.explainHeader(header);
		assertEquals("header should not be null and have a length of 64 bytes", explanation);

		header = new byte[1];
		explanation = BinaryTimeseries.explainHeader(header);
		assertEquals("header should not be null and have a length of 64 bytes", explanation);

		header = new byte[64];
		explanation = BinaryTimeseries.explainHeader(header);
		assertEquals("  0   2 reads 0x00 => invalid endianess check value: 0", explanation);

		// final ByteBuffer buf = ByteBuffer.wrap(header);

	}

	/**
	 * Test that building the binaryTimeseries results in the correct file offsets.
	 */
	@Test
	public void testBuildBinaryTimeseries() {

		final byte[] time_dtypes = new byte[] { BinaryTimeseries.DTYPE_LONG, BinaryTimeseries.DTYPE_DOUBLE };

		final byte[] scaling_dtypes = new byte[] { BinaryTimeseries.DTYPE_NONE, BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT, BinaryTimeseries.DTYPE_INT, BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT, BinaryTimeseries.DTYPE_DOUBLE };

		final byte[] data_dtypes = new byte[] { BinaryTimeseries.DTYPE_BYTE, BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT, BinaryTimeseries.DTYPE_LONG, BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE };

		final int[] data_sizes = new int[] { Byte.BYTES, Short.BYTES, Integer.BYTES, Long.BYTES, Float.BYTES,
				Double.BYTES };

		for (int time_dtype_idx = 0; time_dtype_idx < time_dtypes.length; ++time_dtype_idx) {
			final byte time_dtype = time_dtypes[time_dtype_idx];

			for (int scaling_dtype_idx = 0; scaling_dtype_idx < scaling_dtypes.length; ++scaling_dtype_idx) {
				final byte scaling_dtype = scaling_dtypes[scaling_dtype_idx];

				for (int data_dtype_idx = 0; data_dtype_idx < data_dtypes.length; ++data_dtype_idx) {
					final byte data_dtype = data_dtypes[data_dtype_idx];
					final int data_size = data_sizes[data_dtype_idx];

					final int numSamples = 10;

					final long t0_L = (long) 13.0;
					final double t0_D = (double) 13.0;

					final long dt_L = (long) 37.0;
					final double dt_D = (double) 37.0;

					final byte scalingOffset_B = (byte) 1.2;
					final short scalingOffset_S = (short) 1.2;
					final int scalingOffset_I = (int) 1.2;
					final long scalingOffset_L = (long) 1.2;
					final float scalingOffset_F = (float) 1.2;
					final double scalingOffset_D = (double) 1.2;

					final byte scalingFactor_B = (byte) 24.3;
					final short scalingFactor_S = (short) 24.3;
					final int scalingFactor_I = (int) 24.3;
					final long scalingFactor_L = (long) 24.3;
					final float scalingFactor_F = (float) 24.3;
					final double scalingFactor_D = (double) 24.3;

					// time series:
					// idx | time | value
					// 0 | 13.0 | 1.2
					// 1 | 50.0 | 25.5
					// 2 | 87.0 | 49.8
					// 3 | 124.0 | 74.1
					// 4 | 161.0 | 98.4
					// 5 | 198.0 | 122.7
					// 6 | 235.0 | 147.0
					// 7 | 272.0 | 171.3
					// 8 | 309.0 | 195.6
					// 9 | 346.0 | 219.9

					// compute file size from reserved number of header bytes, sample size and
					// number of samples
					final int filesize = 64 + data_size * numSamples;

					// 'manually' build a BinaryTimeseries
					final byte[] binaryTimeseries = new byte[filesize];
					final ByteBuffer referenceTarget = ByteBuffer.wrap(binaryTimeseries);
					assertEquals(0, referenceTarget.position());
					// endianess check short
					referenceTarget.putShort((short) 1);
					assertEquals(2, referenceTarget.position());
					// dtype of time
					referenceTarget.put(time_dtype);
					assertEquals(3, referenceTarget.position());
					// t0
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(t0_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(t0_D);
					}
					assertEquals(11, referenceTarget.position());
					// dt
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(dt_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(dt_D);
					}
					assertEquals(19, referenceTarget.position());
					// scaling dtype
					referenceTarget.put(scaling_dtype);
					assertEquals(20, referenceTarget.position());
					// scaling offset
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
						referenceTarget.put(scalingOffset_B);
						referenceTarget.put(new byte[8 - Byte.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
						referenceTarget.putShort(scalingOffset_S);
						referenceTarget.put(new byte[8 - Short.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
						referenceTarget.putInt(scalingOffset_I);
						referenceTarget.put(new byte[8 - Integer.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(scalingOffset_L);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						referenceTarget.putFloat(scalingOffset_F);
						referenceTarget.put(new byte[8 - Float.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(scalingOffset_D);
					}
					assertEquals(28, referenceTarget.position());
					// scaling factor
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
						referenceTarget.put(scalingFactor_B);
						referenceTarget.put(new byte[8 - Byte.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
						referenceTarget.putShort(scalingFactor_S);
						referenceTarget.put(new byte[8 - Short.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
						referenceTarget.putInt(scalingFactor_I);
						referenceTarget.put(new byte[8 - Integer.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(scalingFactor_L);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						referenceTarget.putFloat(scalingFactor_F);
						referenceTarget.put(new byte[8 - Float.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(scalingFactor_D);
					}
					assertEquals(36, referenceTarget.position());
					// reserved dummy space
					referenceTarget.put(new byte[23]);
					assertEquals(59, referenceTarget.position());
					// type of raw data
					referenceTarget.put(data_dtype);
					assertEquals(60, referenceTarget.position());
					// number of samples
					referenceTarget.putInt(numSamples);
					assertEquals(64, referenceTarget.position());
					// actual data
					if (data_dtype == BinaryTimeseries.DTYPE_BYTE) {
						byte sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (byte) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (byte) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (byte) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (byte) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (byte) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (byte) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (byte) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.put(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_SHORT) {
						short sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (short) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (short) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (short) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (short) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (short) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (short) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (short) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putShort(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_INT) {
						int sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (int) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (int) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (int) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (int) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (int) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (int) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (int) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putInt(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_LONG) {
						long sample = 0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (long) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (long) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (long) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (long) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (long) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (long) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (long) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putLong(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						float sample = (float) 0.0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (float) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (float) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (float) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (float) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (float) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (float) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (float) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putFloat(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						double sample = 0.0;
						for (int i = 0; i < numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (double) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (double) (scalingOffset_B + i * scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (double) (scalingOffset_S + i * scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (double) (scalingOffset_I + i * scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (double) (scalingOffset_L + i * scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (double) (scalingOffset_F + i * scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (double) (scalingOffset_D + i * scalingFactor_D);
							}
							referenceTarget.putDouble(sample);
						}
					}
					assertEquals(filesize, referenceTarget.position());
				}
			}
		}
	}

	// block comment headers are:
	// - index of test
	// - data type of time expression
	// - data type of scaling parameters
	// - data type of raw data

	/***********************************
	 * AUTO-GENERATED CODE STARTS HERE *
	 ***********************************/

	// L_N_B
	@Test
	public void testBuiltTimebase_L() {
		final int numSamples = 10;
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;

		// 'manually' build reference time stamps
		final long[] timebase = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			timebase[i] = t0_L + i * dt_L;
		}
		final long[] timebase_subset = new long[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);

		// no sourceOffset and targetOffset given
		final long[] targetTimebase = new long[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_L, dt_L);
		assertArrayEquals(timebase, targetTimebase);

		// sourceOffset and targetOffset are given
		final long[] targetTimebase_subset = new long[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_L, dt_L);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long t_l_L = (long) 80.0;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_L, dt_L, t_l_L));
	}

	@Test
	public void testLastIndexInside_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long t_u_L = (long) 300.0;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_L, dt_L, t_u_L));
	}

	@Test
	public void testFileOffset_B() {
		assertEquals(74, BinaryTimeseries.fileOffset(1, 10));
	}

	@Test
	public void testReadWrite_L_N_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
				(byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_N_S
	@Test
	public void testFileOffset_S() {
		assertEquals(84, BinaryTimeseries.fileOffset(2, 10));
	}

	@Test
	public void testReadWrite_L_N_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x02, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x06, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_N_I
	@Test
	public void testFileOffset_I() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	@Test
	public void testReadWrite_L_N_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_N_L
	@Test
	public void testFileOffset_L() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	@Test
	public void testReadWrite_L_N_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_N_F
	@Test
	public void testFileOffset_F() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	@Test
	public void testReadWrite_L_N_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0xA0, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0x10, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_N_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_N_D
	@Test
	public void testFileOffset_D() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	@Test
	public void testReadWrite_L_N_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_N_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x14, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x1C, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x22, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_N_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_N_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_N_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_B
	@Test
	public void testReadWrite_L_B_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_S
	@Test
	public void testReadWrite_L_B_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_I
	@Test
	public void testReadWrite_L_B_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_L
	@Test
	public void testReadWrite_L_B_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_F
	@Test
	public void testReadWrite_L_B_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_B_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_B_D
	@Test
	public void testReadWrite_L_B_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_B_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_B_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_B_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_B_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_B
	@Test
	public void testReadWrite_L_S_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_S
	@Test
	public void testReadWrite_L_S_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_I
	@Test
	public void testReadWrite_L_S_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_L
	@Test
	public void testReadWrite_L_S_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_F
	@Test
	public void testReadWrite_L_S_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_S_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_S_D
	@Test
	public void testReadWrite_L_S_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_S_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_S_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_S_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_S_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_B
	@Test
	public void testReadWrite_L_I_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_S
	@Test
	public void testReadWrite_L_I_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_I
	@Test
	public void testReadWrite_L_I_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_L
	@Test
	public void testReadWrite_L_I_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_F
	@Test
	public void testReadWrite_L_I_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_I_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_I_D
	@Test
	public void testReadWrite_L_I_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_I_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_I_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_I_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_I_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_B
	@Test
	public void testReadWrite_L_L_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_S
	@Test
	public void testReadWrite_L_L_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_I
	@Test
	public void testReadWrite_L_L_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_L
	@Test
	public void testReadWrite_L_L_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_F
	@Test
	public void testReadWrite_L_L_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_L_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_L_D
	@Test
	public void testReadWrite_L_L_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_L_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_L_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_L_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_L_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_B
	@Test
	public void testReadWrite_L_F_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62,
				(byte) 0x7A, (byte) 0x92, (byte) 0xAB, (byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_S
	@Test
	public void testReadWrite_L_F_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00,
				(byte) 0x92, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_I
	@Test
	public void testReadWrite_L_F_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_L
	@Test
	public void testReadWrite_L_F_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_F
	@Test
	public void testReadWrite_L_F_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41,
				(byte) 0xCC, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42,
				(byte) 0x94, (byte) 0x33, (byte) 0x32, (byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCC, (byte) 0x42,
				(byte) 0xF5, (byte) 0x66, (byte) 0x66, (byte) 0x43, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0x43,
				(byte) 0x2B, (byte) 0x4C, (byte) 0xCC, (byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x99, (byte) 0x43,
				(byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_L_F_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_F_D
	@Test
	public void testReadWrite_L_F_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_F_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x60,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x40,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x80,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xC0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x5F, (byte) 0xFF, (byte) 0xE0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x80,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x20,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xC0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_F_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_F_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_F_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_B
	@Test
	public void testReadWrite_L_D_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62,
				(byte) 0x7A, (byte) 0x93, (byte) 0xAB, (byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_S
	@Test
	public void testReadWrite_L_D_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00,
				(byte) 0x93, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_I
	@Test
	public void testReadWrite_L_D_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_L
	@Test
	public void testReadWrite_L_D_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_F
	@Test
	public void testReadWrite_L_D_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41,
				(byte) 0xCC, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42,
				(byte) 0x94, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCD, (byte) 0x42,
				(byte) 0xF5, (byte) 0x66, (byte) 0x66, (byte) 0x43, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x2B, (byte) 0x4C, (byte) 0xCD, (byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x9A, (byte) 0x43,
				(byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_L_D_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// L_D_D
	@Test
	public void testReadWrite_L_D_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_L_D_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33,
				(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x66,
				(byte) 0x66, (byte) 0x66, (byte) 0x67, (byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x66,
				(byte) 0x66, (byte) 0x66, (byte) 0x67, (byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x99,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xCC,
				(byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x40, (byte) 0x62, (byte) 0x60, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x99,
				(byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x33,
				(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xCC,
				(byte) 0xCC, (byte) 0xCC, (byte) 0xCD };
		assertArrayEquals(referenceBTS_L_D_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_L_D_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_L_D_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(4, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_L, BinaryTimeseries.readTimeT0_long(source));
		assertEquals(11, source.position());
		assertEquals(dt_L, BinaryTimeseries.readTimeDt_long(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_B
	@Test
	public void testBuiltTimebase_D() {
		final int numSamples = 10;
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;

		// 'manually' build reference time stamps
		final double[] timebase = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			timebase[i] = t0_D + i * dt_D;
		}
		final double[] timebase_subset = new double[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);

		// no sourceOffset and targetOffset given
		final double[] targetTimebase = new double[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_D, dt_D);
		assertArrayEquals(timebase, targetTimebase);

		// sourceOffset and targetOffset are given
		final double[] targetTimebase_subset = new double[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_D, dt_D);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double t_l_D = (double) 80.0;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_D, dt_D, t_l_D));
	}

	@Test
	public void testLastIndexInside_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double t_u_D = (double) 300.0;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_D, dt_D, t_u_D));
	}

	@Test
	public void testReadWrite_D_N_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
				(byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_S
	@Test
	public void testReadWrite_D_N_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x02, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x06, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_I
	@Test
	public void testReadWrite_D_N_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_L
	@Test
	public void testReadWrite_D_N_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_F
	@Test
	public void testReadWrite_D_N_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0xA0, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x40,
				(byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0x10, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_N_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_N_D
	@Test
	public void testReadWrite_D_N_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) i;
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScalingDisabled(target);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_N_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x14, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x1C, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x22, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_N_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_N_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_N_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(0, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		BinaryTimeseries.readScalingDisabled(source);
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			referenceData_byte[i] = (byte) i;
			referenceData_short[i] = (short) i;
			referenceData_int[i] = (int) i;
			referenceData_long[i] = (long) i;
			referenceData_float[i] = (float) i;
			referenceData_double[i] = (double) i;
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_B
	@Test
	public void testReadWrite_D_B_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_S
	@Test
	public void testReadWrite_D_B_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_I
	@Test
	public void testReadWrite_D_B_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_L
	@Test
	public void testReadWrite_D_B_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_F
	@Test
	public void testReadWrite_D_B_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_B_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_B_D
	@Test
	public void testReadWrite_D_B_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_B + i * scalingFactor_B);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_B_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_B_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_B_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_B_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(1, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_B, BinaryTimeseries.readScalingOffset_byte(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_B, BinaryTimeseries.readScalingFactor_byte(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_B + i * scalingFactor_B);
			referenceData_byte[i] = (byte) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_short[i] = (short) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_int[i] = (int) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_long[i] = (long) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_float[i] = (float) (scalingOffset_B + referenceValue * scalingFactor_B);
			referenceData_double[i] = (double) (scalingOffset_B + referenceValue * scalingFactor_B);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_B
	@Test
	public void testReadWrite_D_S_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_S
	@Test
	public void testReadWrite_D_S_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_I
	@Test
	public void testReadWrite_D_S_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_L
	@Test
	public void testReadWrite_D_S_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_F
	@Test
	public void testReadWrite_D_S_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_S_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_S_D
	@Test
	public void testReadWrite_D_S_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_S + i * scalingFactor_S);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_S_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_S_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_S_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_S_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(2, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_S, BinaryTimeseries.readScalingOffset_short(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_S, BinaryTimeseries.readScalingFactor_short(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_S + i * scalingFactor_S);
			referenceData_byte[i] = (byte) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_short[i] = (short) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_int[i] = (int) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_long[i] = (long) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_float[i] = (float) (scalingOffset_S + referenceValue * scalingFactor_S);
			referenceData_double[i] = (double) (scalingOffset_S + referenceValue * scalingFactor_S);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_B
	@Test
	public void testReadWrite_D_I_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_S
	@Test
	public void testReadWrite_D_I_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_I
	@Test
	public void testReadWrite_D_I_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_L
	@Test
	public void testReadWrite_D_I_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_F
	@Test
	public void testReadWrite_D_I_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_I_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_I_D
	@Test
	public void testReadWrite_D_I_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_I + i * scalingFactor_I);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_I_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_I_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_I_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_I_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(3, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_I, BinaryTimeseries.readScalingOffset_int(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_I, BinaryTimeseries.readScalingFactor_int(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_I + i * scalingFactor_I);
			referenceData_byte[i] = (byte) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_short[i] = (short) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_int[i] = (int) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_long[i] = (long) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_float[i] = (float) (scalingOffset_I + referenceValue * scalingFactor_I);
			referenceData_double[i] = (double) (scalingOffset_I + referenceValue * scalingFactor_I);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_B
	@Test
	public void testReadWrite_D_L_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61,
				(byte) 0x79, (byte) 0x91, (byte) 0xA9, (byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_S
	@Test
	public void testReadWrite_D_L_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00,
				(byte) 0x91, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_I
	@Test
	public void testReadWrite_D_L_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_L
	@Test
	public void testReadWrite_D_L_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x49, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xA9, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_F
	@Test
	public void testReadWrite_D_L_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC8, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42,
				(byte) 0xF2, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_L_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_L_D
	@Test
	public void testReadWrite_D_L_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_L + i * scalingFactor_L);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_L_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_L_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_L_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_L_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(4, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_L, BinaryTimeseries.readScalingOffset_long(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_L, BinaryTimeseries.readScalingFactor_long(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_L + i * scalingFactor_L);
			referenceData_byte[i] = (byte) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_short[i] = (short) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_int[i] = (int) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_long[i] = (long) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_float[i] = (float) (scalingOffset_L + referenceValue * scalingFactor_L);
			referenceData_double[i] = (double) (scalingOffset_L + referenceValue * scalingFactor_L);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_B
	@Test
	public void testReadWrite_D_F_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62,
				(byte) 0x7A, (byte) 0x92, (byte) 0xAB, (byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_S
	@Test
	public void testReadWrite_D_F_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00,
				(byte) 0x92, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_I
	@Test
	public void testReadWrite_D_F_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_L
	@Test
	public void testReadWrite_D_F_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_F
	@Test
	public void testReadWrite_D_F_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41,
				(byte) 0xCC, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42,
				(byte) 0x94, (byte) 0x33, (byte) 0x32, (byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCC, (byte) 0x42,
				(byte) 0xF5, (byte) 0x66, (byte) 0x66, (byte) 0x43, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0x43,
				(byte) 0x2B, (byte) 0x4C, (byte) 0xCC, (byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x99, (byte) 0x43,
				(byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_D_F_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_F_D
	@Test
	public void testReadWrite_D_F_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_F + i * scalingFactor_F);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_F_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
				(byte) 0xC2, (byte) 0x66, (byte) 0x66, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x60,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x40,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x80,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xC0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x62, (byte) 0x5F, (byte) 0xFF, (byte) 0xE0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x80,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x20,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xC0,
				(byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_F_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_F_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_F_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(5, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_F, BinaryTimeseries.readScalingOffset_float(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_F, BinaryTimeseries.readScalingFactor_float(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_F + i * scalingFactor_F);
			referenceData_byte[i] = (byte) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_short[i] = (short) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_int[i] = (int) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_long[i] = (long) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_float[i] = (float) (scalingOffset_F + referenceValue * scalingFactor_F);
			referenceData_double[i] = (double) (scalingOffset_F + referenceValue * scalingFactor_F);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_B
	@Test
	public void testReadWrite_D_D_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (byte) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_B = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62,
				(byte) 0x7A, (byte) 0x93, (byte) 0xAB, (byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_B, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_B);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(1, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final byte[] rawData = new byte[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final byte referenceValue = (byte) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_S
	@Test
	public void testReadWrite_D_D_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (short) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_S = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00,
				(byte) 0x31, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00,
				(byte) 0x93, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_S, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_S);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(2, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final short[] rawData = new short[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final short referenceValue = (short) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_I
	@Test
	public void testReadWrite_D_D_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (int) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_I = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_I, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_I);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(3, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final int[] rawData = new int[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final int referenceValue = (int) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_L
	@Test
	public void testReadWrite_D_D_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (long) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_L = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x4A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xAB, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_L, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_L);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(4, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final long[] rawData = new long[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final long referenceValue = (long) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_F
	@Test
	public void testReadWrite_D_D_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (float) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_F = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41,
				(byte) 0xCC, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42,
				(byte) 0x94, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCD, (byte) 0x42,
				(byte) 0xF5, (byte) 0x66, (byte) 0x66, (byte) 0x43, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x43,
				(byte) 0x2B, (byte) 0x4C, (byte) 0xCD, (byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x9A, (byte) 0x43,
				(byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_D_D_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_F, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_F);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(5, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final float[] rawData = new float[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final float referenceValue = (float) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	// D_D_D
	@Test
	public void testReadWrite_D_D_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			values[i] = (double) (scalingOffset_D + i * scalingFactor_D);
		}
		// writing
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		assertEquals(0, target.position());
		BinaryTimeseries.writeEndianessCheckValue(target);
		assertEquals(2, target.position());
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		assertEquals(19, target.position());
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		assertEquals(36, target.position());
		BinaryTimeseries.writeReservedDummy(target);
		assertEquals(59, target.position());
		BinaryTimeseries.writeData(target, values);
		assertEquals(fileSize, target.position());
		final byte[] referenceBTS_D_D_D = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42,
				(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F,
				(byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40,
				(byte) 0x38, (byte) 0x4C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33,
				(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x66,
				(byte) 0x66, (byte) 0x66, (byte) 0x67, (byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x66,
				(byte) 0x66, (byte) 0x66, (byte) 0x67, (byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x99,
				(byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xCC,
				(byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x40, (byte) 0x62, (byte) 0x60, (byte) 0x00, (byte) 0x00,
				(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x99,
				(byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x33,
				(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xCC,
				(byte) 0xCC, (byte) 0xCC, (byte) 0xCD };
		assertArrayEquals(referenceBTS_D_D_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertEquals(fileSize, target.position());
		assertArrayEquals(referenceBTS_D_D_D, targetArr);
		// reading
		final ByteBuffer source = ByteBuffer.wrap(referenceBTS_D_D_D);
		assertEquals(0, source.position());
		assertEquals(true, BinaryTimeseries.readEndianessOk(source));
		assertEquals(2, source.position());
		assertEquals(6, BinaryTimeseries.readTimeType(source));
		assertEquals(3, source.position());
		assertEquals(t0_D, BinaryTimeseries.readTimeT0_double(source));
		assertEquals(11, source.position());
		assertEquals(dt_D, BinaryTimeseries.readTimeDt_double(source));
		assertEquals(19, source.position());
		assertEquals(6, BinaryTimeseries.readScalingType(source));
		assertEquals(20, source.position());
		assertEquals(scalingOffset_D, BinaryTimeseries.readScalingOffset_double(source));
		assertEquals(28, source.position());
		assertEquals(scalingFactor_D, BinaryTimeseries.readScalingFactor_double(source));
		assertEquals(36, source.position());
		assertEquals(36, source.position());
		BinaryTimeseries.readReservedDummy(source);
		assertEquals(59, source.position());
		assertEquals(6, BinaryTimeseries.readDataType(source));
		assertEquals(60, source.position());
		assertEquals(numSamples, BinaryTimeseries.readNumSamples(source));
		assertEquals(64, source.position());
		final double[] rawData = new double[numSamples];
		BinaryTimeseries.readRawData(source, rawData, 0, numSamples);
		assertEquals(fileSize, source.position());
		assertArrayEquals(values, rawData);
		// read and scale into given primitive array
		final byte[] referenceData_byte = new byte[numSamples];
		final short[] referenceData_short = new short[numSamples];
		final int[] referenceData_int = new int[numSamples];
		final long[] referenceData_long = new long[numSamples];
		final float[] referenceData_float = new float[numSamples];
		final double[] referenceData_double = new double[numSamples];
		for (int i = 0; i < numSamples; ++i) {
			final double referenceValue = (double) (scalingOffset_D + i * scalingFactor_D);
			referenceData_byte[i] = (byte) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_short[i] = (short) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_int[i] = (int) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_long[i] = (long) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_float[i] = (float) (scalingOffset_D + referenceValue * scalingFactor_D);
			referenceData_double[i] = (double) (scalingOffset_D + referenceValue * scalingFactor_D);
		}
		source.position(19);
		final byte[] data_byte = BinaryTimeseries.readData_byte(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_byte, data_byte);
		source.position(19);
		final short[] data_short = BinaryTimeseries.readData_short(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_short, data_short);
		source.position(19);
		final int[] data_int = BinaryTimeseries.readData_int(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_int, data_int);
		source.position(19);
		final long[] data_long = BinaryTimeseries.readData_long(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_long, data_long);
		source.position(19);
		final float[] data_float = BinaryTimeseries.readData_float(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_float, data_float);
		source.position(19);
		final double[] data_double = BinaryTimeseries.readData_double(source);
		assertEquals(fileSize, source.position());
		assertArrayEquals(referenceData_double, data_double);
	}

	/***********************************
	 * AUTO-GENERATED CODE ENDS HERE *
	 ***********************************/
}
