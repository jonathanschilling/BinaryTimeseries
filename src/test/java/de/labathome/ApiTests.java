package de.labathome;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.Test;

/**
 * The purpose of this test class is to check the full API of BinaryTimeseries for consistency.
 * The test code can be automagically generated by running the {@code main} method of this class.
 * 
 * @author Jonathan Schilling (jonathan.schilling@mail.de)
 */
public class ApiTests {

	/**
	 * Generate all test methods in this class and print the source code to the command line.
	 * @param args ignored
	 */
	public static void main(String[] args) {
		
		final byte[] time_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] scaling_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_NONE,
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] data_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final int[] data_sizes = new int[] {
				Byte.BYTES,
				Short.BYTES,
				Integer.BYTES,
				Long.BYTES,
				Float.BYTES,
				Double.BYTES
		};
		
		final Map<Byte, String> javaName = new HashMap<>();
		javaName.put(BinaryTimeseries.DTYPE_NONE,     "null");
		javaName.put(BinaryTimeseries.DTYPE_BYTE,     "byte");
		javaName.put(BinaryTimeseries.DTYPE_SHORT,   "short");
		javaName.put(BinaryTimeseries.DTYPE_INT,       "int");
		javaName.put(BinaryTimeseries.DTYPE_LONG,     "long");
		javaName.put(BinaryTimeseries.DTYPE_FLOAT,   "float");
		javaName.put(BinaryTimeseries.DTYPE_DOUBLE, "double");
		
		for (int time_dtype_idx=0; time_dtype_idx<time_dtypes.length; ++time_dtype_idx) {
			final byte time_dtype = time_dtypes[time_dtype_idx];
			final String tT = BinaryTimeseries.dtypeStr(time_dtype);
			String jtT = javaName.get(time_dtype);

			for (int scaling_dtype_idx=0; scaling_dtype_idx<scaling_dtypes.length; ++scaling_dtype_idx) {
				final byte scaling_dtype = scaling_dtypes[scaling_dtype_idx];
				final String tS = BinaryTimeseries.dtypeStr(scaling_dtype);
				String jtS = javaName.get(scaling_dtype);
				
				for (int data_dtype_idx=0; data_dtype_idx<data_dtypes.length; ++data_dtype_idx) {
					final byte data_dtype = data_dtypes[data_dtype_idx];
					final String tD = BinaryTimeseries.dtypeStr(data_dtype);
					String jtD = javaName.get(data_dtype);
					final int data_size = data_sizes[data_dtype_idx];
					
					final String testId = tT+"_"+tS+"_"+tD;
					System.out.println("	// "+testId);
					
					final String numSamplesStr = "10";
					final int numSamples = Integer.parseInt(numSamplesStr);
					
					final String t0Str = "13.0";
					final double t0 = Double.parseDouble(t0Str);
					final   long t0_L =   (long) t0;
					final double t0_D = (double) t0;
					
					final String dtStr = "37.0";
					final double dt = Double.parseDouble(dtStr);
					final   long dt_L =   (long) dt;
					final double dt_D = (double) dt;
					
					final String scalingOffsetStr = "1.2";
					final double scalingOffset = Double.parseDouble(scalingOffsetStr);
					final   byte scalingOffset_B = (byte)  scalingOffset;
					final  short scalingOffset_S = (short) scalingOffset;
					final    int scalingOffset_I = (int)   scalingOffset;
					final   long scalingOffset_L = (long)  scalingOffset;
					final  float scalingOffset_F = (float) scalingOffset;
					final double scalingOffset_D = (double)scalingOffset;
					
					final String scalingFactorStr = "24.3";
					final double scalingFactor = Double.parseDouble(scalingFactorStr);
					final   byte scalingFactor_B = (byte)  scalingFactor;
					final  short scalingFactor_S = (short) scalingFactor;
					final    int scalingFactor_I = (int)   scalingFactor;
					final   long scalingFactor_L = (long)  scalingFactor;
					final  float scalingFactor_F = (float) scalingFactor;
					final double scalingFactor_D = (double)scalingFactor;
					
					// time series:
					// idx | time  | value
					//   0 |  13.0 |   1.2
					//   1 |  50.0 |  25.5
					//   2 |  87.0 |  49.8
					//   3 | 124.0 |  74.1
					//   4 | 161.0 |  98.4
					//   5 | 198.0 | 122.7
					//   6 | 235.0 | 147.0
					//   7 | 272.0 | 171.3
					//   8 | 309.0 | 195.6
					//   9 | 346.0 | 219.9
					
					final int numSamplesSubset = 5;
					final int sourceOffset = 2;
					final int targetOffset = 0;
					
					final String t_lStr =  "80.0"; // => firstIndexInside = 2
					final String t_uStr = "300.0"; // =>  lastIndexInside = 7
					
					// compute file size from reserved number of header bytes, sample size and number of samples
					final int filesize = 64 + data_size*numSamples;
					
					final byte[] binaryTimeseries = new byte[filesize];
					
					// check static routines
					if (scaling_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per time type
						
						// buildTimebase
						System.out.println("	@Test\n"+
								"	public void testBuiltTimebase_"+tT+"() {\n"+
								"		final int numSamples = "+numSamplesStr+";\n"+
								"		final "+jtT+" t0_"+tT+" = ("+jtT+") "+t0Str+";\n"+
								"		final "+jtT+" dt_"+tT+" = ("+jtT+") "+dtStr+";\n"+
								"		final int numSamplesSubset = "+numSamplesSubset+";\n"+
								"		final int sourceOffset = "+sourceOffset+";\n"+
								"		final int targetOffset = "+targetOffset+";\n"+
								"		\n"+
								"		// 'manually' build reference time stamps\n"+ 
								"		final "+jtT+"[] timebase = new "+jtT+"[numSamples];\n"+
								"		for (int i=0; i<numSamples; ++i) {\n"+
								"			timebase[i] = t0_"+tT+" + i*dt_"+tT+";\n"+
								"		}\n"+
								"		final "+jtT+"[] timebase_subset = new "+jtT+"[numSamplesSubset];\n"+
								"		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);\n"+
								"		\n"+
								"		// no sourceOffset and targetOffset given\n"+
								"		final "+jtT+"[] targetTimebase = new "+jtT+"[numSamples];\n"+
								"		BinaryTimeseries.buildTimebase(targetTimebase, t0_"+tT+", dt_"+tT+");\n"+
								"		assertArrayEquals(timebase, targetTimebase);\n"+
								"		\n"+
								"		// sourceOffset and targetOffset are given\n"+
								"		final "+jtT+"[] targetTimebase_subset = new "+jtT+"[numSamplesSubset];\n"+
								"		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_"+tT+", dt_"+tT+");\n"+
								"		assertArrayEquals(timebase_subset, targetTimebase_subset);\n"+
								"	}\n");
						
						// testFirstIndexInside
						System.out.println("	@Test\n"+
								"	public void testFirstIndexInside_"+tT+"() {\n"+
								"		final "+jtT+" t0_"+tT+"  = ("+jtT+") "+t0Str+";\n"+
								"		final "+jtT+" dt_"+tT+"  = ("+jtT+") "+dtStr+";\n"+
								"		final "+jtT+" t_l_"+tT+" = ("+jtT+") "+t_lStr+";\n"+
								"		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_"+tT+", dt_"+tT+", t_l_"+tT+"));\n"+
								"	}\n");
						
						// testLastIndexInside
						System.out.println("	@Test\n"+
								"	public void testLastIndexInside_"+tT+"() {\n"+
								"		final "+jtT+" t0_"+tT+"  = ("+jtT+") "+t0Str+";\n"+
								"		final "+jtT+" dt_"+tT+"  = ("+jtT+") "+dtStr+";\n"+
								"		final "+jtT+" t_u_"+tT+" = ("+jtT+") "+t_uStr+";\n"+
								"		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_"+tT+", dt_"+tT+", t_u_"+tT+"));\n"+
								"	}\n");
					}
					
					if (time_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per scaling type

					}
					
					if (time_dtype_idx == 0 && scaling_dtype_idx == 0) {
						// these need to be executed only once per data type
						
						// fileOffset
						System.out.println("	@Test\n"+
								"	public void testFileOffset_"+tD+"() {\n"+
								"		assertEquals("+filesize+", BinaryTimeseries.fileOffset("+data_size+", "+numSamplesStr+"));\n"+
								"	}\n");
					}
					
					
					
					
					// code for testing the API write and read methods
					String writeTestCode = "	@Test\n"+
							"	public void testWriting_"+testId+"() {\n";
					
					
					String readTestCode = "	@Test\n"+
							"	public void testReading_"+testId+"() {\n";
					
					
					
					
				
					
					// 'manually' build a BinaryTimeseries
					final ByteBuffer referenceTarget = ByteBuffer.wrap(binaryTimeseries);
					//assertEquals(0, referenceTarget.position());
					// endianess check short
					referenceTarget.putShort((short)1);
					//assertEquals(2, referenceTarget.position());
					// dtype of time
					referenceTarget.put(time_dtype);
					//assertEquals(3, referenceTarget.position());

					// t0
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(t0_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(t0_D);
					}
					//assertEquals(11, referenceTarget.position());
					
					writeTestCode += "		final "+jtT+" t0_"+tT+" = ("+jtT+") "+t0Str+";\n";
					
					// dt
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(dt_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(dt_D);
					}
					//assertEquals(19, referenceTarget.position());

					writeTestCode += "		final "+jtT+" dt_"+tT+" = ("+jtT+") "+dtStr+";\n";
					
					// scaling dtype
					referenceTarget.put(scaling_dtype);
					//assertEquals(20, referenceTarget.position());
					
					// scaling offset
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else {
						if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
							referenceTarget.put(scalingOffset_B);
							referenceTarget.put(new byte[8-Byte.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
							referenceTarget.putShort(scalingOffset_S);
							referenceTarget.put(new byte[8-Short.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
							referenceTarget.putInt(scalingOffset_I);
							referenceTarget.put(new byte[8-Integer.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
							referenceTarget.putLong(scalingOffset_L);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
							referenceTarget.putFloat(scalingOffset_F);
							referenceTarget.put(new byte[8-Float.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
							referenceTarget.putDouble(scalingOffset_D);
						}
						writeTestCode += "		final "+jtS+" scalingOffset_"+tS+" = ("+jtS+") "+scalingOffsetStr+";\n";
					}
					//assertEquals(28, referenceTarget.position());
					
					// scaling factor
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else {
						if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
							referenceTarget.put(scalingFactor_B);
							referenceTarget.put(new byte[8-Byte.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
							referenceTarget.putShort(scalingFactor_S);
							referenceTarget.put(new byte[8-Short.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
							referenceTarget.putInt(scalingFactor_I);
							referenceTarget.put(new byte[8-Integer.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
							referenceTarget.putLong(scalingFactor_L);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
							referenceTarget.putFloat(scalingFactor_F);
							referenceTarget.put(new byte[8-Float.BYTES]);
						} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
							referenceTarget.putDouble(scalingFactor_D);
						}
						writeTestCode += "		final "+jtS+" scalingFactor_"+tS+" = ("+jtS+") "+scalingFactorStr+";\n";
					}
					//assertEquals(36, referenceTarget.position());
					
					// reserved dummy space
					referenceTarget.put(new byte[23]);
					//assertEquals(59, referenceTarget.position());
					
					// type of raw data
					referenceTarget.put(data_dtype);
					//assertEquals(60, referenceTarget.position());
					
					// number of samples
					referenceTarget.putInt(numSamples);
					//assertEquals(64, referenceTarget.position());
					
					writeTestCode += "		final int numSamples = "+numSamplesStr+";\n";
					
					// actual data
					Object samples = null;
					if (data_dtype == BinaryTimeseries.DTYPE_BYTE) {
						samples = new byte[numSamples];
						byte sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (byte) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (byte) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (byte) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (byte) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (byte) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (byte) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (byte) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.put(sample);
							((byte[])samples)[i] = sample;
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_SHORT) {
						samples = new short[numSamples];
						short sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (short) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (short) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (short) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (short) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (short) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (short) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (short) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putShort(sample);
							((short[])samples)[i] = sample;
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_INT) {
						samples = new int[numSamples];
						int sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (int) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (int) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (int) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (int) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (int) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (int) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (int) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putInt(sample);
							((int[])samples)[i] = sample;
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_LONG) {
						samples = new long[numSamples];
						long sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (long) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (long) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (long) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (long) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (long) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (long) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (long) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putLong(sample);
							((long[])samples)[i] = sample;
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						samples = new float[numSamples];
						float sample = (float) 0.0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (float) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (float) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (float) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (float) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (float) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (float) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (float) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putFloat(sample);
							((float[])samples)[i] = sample;
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						samples = new double[numSamples];
						double sample = 0.0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (double) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (double) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (double) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (double) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (double) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (double) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (double) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putDouble(sample);
							((double[])samples)[i] = sample;
						}
					}
					//assertEquals(filesize, referenceTarget.position());
					
					writeTestCode += "		final "+jtD+"[] values = new "+jtD+"[numSamples];\n"+
							"		for (int i=0; i<numSamples; ++i) {\n";
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "			values[i] = ("+jtD+") i;\n";
					} else {
						writeTestCode += "			values[i] = ("+jtD+") (scalingOffset_"+tS+" + i*scalingFactor_"+tS+");\n";
					}
					writeTestCode += "		}\n"+
							"		int fileSize = BinaryTimeseries.fileOffset("+data_size+", numSamples);\n"+
							"		final byte[] targetArr = new byte[fileSize];\n" +
							"		final ByteBuffer target = ByteBuffer.wrap(targetArr);\n" +
							"		BinaryTimeseries.writeEndianessCheckValue(target);\n" +
							"		BinaryTimeseries.writeTimebase(target, t0_"+tT+", dt_"+tT+");\n";
					
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						writeTestCode += "		BinaryTimeseries.writeScalingDisabled(target);\n";
					} else {
						writeTestCode += "		BinaryTimeseries.writeScaling(target, scalingOffset_"+tS+", scalingFactor_"+tS+");\n";
					}
							
					writeTestCode += "		BinaryTimeseries.writeReservedDummy(target);\n" +
							"		BinaryTimeseries.writeData(target, values);\n";
					
					// generate textual representation of byte array containing the reference BinaryTimeseries
					String btsDef = "final byte[] referenceBTS_"+testId+" = new byte[] {\n\t";
					for (int i=0; i<filesize-1; ++i) {
						if ((i+1)%8==0) {
							btsDef += String.format("(byte) 0x%02X,\n\t", binaryTimeseries[i]); 
						} else {
							btsDef += String.format("(byte) 0x%02X, ", binaryTimeseries[i]);
						}
					}
					btsDef += String.format("(byte) 0x%02X };", binaryTimeseries[filesize-1]);

					// adjust indentation
					writeTestCode += "		"+btsDef.replace("\t", "\t\t\t")+"\n";
					
					// finally actually check the array contents
					writeTestCode += "		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";

					
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						// rewind and re-check using write() without scaling
						writeTestCode += "		target.position(0);\n" +
						"		BinaryTimeseries.write(target, t0_"+tT+", dt_"+tT+", values);\n" +
						"		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";
					} else {
						// rewind and re-check using write() with scaling
						writeTestCode += "		target.position(0);\n" +
								"		BinaryTimeseries.write(target, t0_"+tT+", dt_"+tT+", values, scalingOffset_"+tS+", scalingFactor_"+tS+");\n" +
								"		assertArrayEquals(referenceBTS_"+testId+", targetArr);\n";
					}
					
					
					
					
					// check reading routines
					
					
					
					
					
					
					
					writeTestCode += "	}\n";
					readTestCode  += "	}\n";
					
					System.out.println(writeTestCode);
					System.out.println(readTestCode);
				}
			}
			
		}
	}
	
	/**
	 * Test that building the binaryTimeseries results in the correct file offsets.
	 */
	@Test
	public void testBuildBinaryTimeseries() {
		
		final byte[] time_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] scaling_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_NONE,
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] data_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final int[] data_sizes = new int[] {
				Byte.BYTES,
				Short.BYTES,
				Integer.BYTES,
				Long.BYTES,
				Float.BYTES,
				Double.BYTES
		};
		
		for (int time_dtype_idx=0; time_dtype_idx<time_dtypes.length; ++time_dtype_idx) {
			final byte time_dtype = time_dtypes[time_dtype_idx];
			
			for (int scaling_dtype_idx=0; scaling_dtype_idx<scaling_dtypes.length; ++scaling_dtype_idx) {
				final byte scaling_dtype = scaling_dtypes[scaling_dtype_idx];
				
				for (int data_dtype_idx=0; data_dtype_idx<data_dtypes.length; ++data_dtype_idx) {
					final byte data_dtype = data_dtypes[data_dtype_idx];
					final int data_size = data_sizes[data_dtype_idx];
					
					final int numSamples = 10;
					
					final   long t0_L =   (long) 13.0;
					final double t0_D = (double) 13.0;
					
					final   long dt_L =   (long) 37.0;
					final double dt_D = (double) 37.0;
					
					final   byte scalingOffset_B =   (byte) 1.2;
					final  short scalingOffset_S =  (short) 1.2;
					final    int scalingOffset_I =    (int) 1.2;
					final   long scalingOffset_L =   (long) 1.2;
					final  float scalingOffset_F =  (float) 1.2;
					final double scalingOffset_D = (double) 1.2;
					
					final   byte scalingFactor_B =   (byte) 24.3;
					final  short scalingFactor_S =  (short) 24.3;
					final    int scalingFactor_I =    (int) 24.3;
					final   long scalingFactor_L =   (long) 24.3;
					final  float scalingFactor_F =  (float) 24.3;
					final double scalingFactor_D = (double) 24.3;
					
					// time series:
					// idx | time  | value
					//   0 |  13.0 |   1.2
					//   1 |  50.0 |  25.5
					//   2 |  87.0 |  49.8
					//   3 | 124.0 |  74.1
					//   4 | 161.0 |  98.4
					//   5 | 198.0 | 122.7
					//   6 | 235.0 | 147.0
					//   7 | 272.0 | 171.3
					//   8 | 309.0 | 195.6
					//   9 | 346.0 | 219.9
					
					// compute file size from reserved number of header bytes, sample size and number of samples
					final int filesize = 64 + data_size*numSamples;
					
					// 'manually' build a BinaryTimeseries
					final byte[] binaryTimeseries = new byte[filesize];
					final ByteBuffer referenceTarget = ByteBuffer.wrap(binaryTimeseries);
					assertEquals(0, referenceTarget.position());
					// endianess check short
					referenceTarget.putShort((short)1);
					assertEquals(2, referenceTarget.position());
					// dtype of time
					referenceTarget.put(time_dtype);
					assertEquals(3, referenceTarget.position());
					// t0
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(t0_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(t0_D);
					}
					assertEquals(11, referenceTarget.position());
					// dt
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(dt_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(dt_D);
					}
					assertEquals(19, referenceTarget.position());
					// scaling dtype
					referenceTarget.put(scaling_dtype);
					assertEquals(20, referenceTarget.position());
					// scaling offset
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
						referenceTarget.put(scalingOffset_B);
						referenceTarget.put(new byte[8-Byte.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
						referenceTarget.putShort(scalingOffset_S);
						referenceTarget.put(new byte[8-Short.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
						referenceTarget.putInt(scalingOffset_I);
						referenceTarget.put(new byte[8-Integer.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(scalingOffset_L);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						referenceTarget.putFloat(scalingOffset_F);
						referenceTarget.put(new byte[8-Float.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(scalingOffset_D);
					}
					assertEquals(28, referenceTarget.position());
					// scaling factor
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						referenceTarget.put(new byte[8]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
						referenceTarget.put(scalingFactor_B);
						referenceTarget.put(new byte[8-Byte.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
						referenceTarget.putShort(scalingFactor_S);
						referenceTarget.put(new byte[8-Short.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
						referenceTarget.putInt(scalingFactor_I);
						referenceTarget.put(new byte[8-Integer.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
						referenceTarget.putLong(scalingFactor_L);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						referenceTarget.putFloat(scalingFactor_F);
						referenceTarget.put(new byte[8-Float.BYTES]);
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						referenceTarget.putDouble(scalingFactor_D);
					}
					assertEquals(36, referenceTarget.position());
					// reserved dummy space
					referenceTarget.put(new byte[23]);
					assertEquals(59, referenceTarget.position());
					// type of raw data
					referenceTarget.put(data_dtype);
					assertEquals(60, referenceTarget.position());
					// number of samples
					referenceTarget.putInt(numSamples);
					assertEquals(64, referenceTarget.position());
					// actual data
					if (data_dtype == BinaryTimeseries.DTYPE_BYTE) {
						byte sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (byte) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (byte) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (byte) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (byte) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (byte) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (byte) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (byte) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.put(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_SHORT) {
						short sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (short) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (short) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (short) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (short) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (short) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (short) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (short) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putShort(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_INT) {
						int sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (int) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (int) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (int) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (int) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (int) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (int) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (int) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putInt(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_LONG) {
						long sample = 0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (long) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (long) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (long) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (long) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (long) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (long) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (long) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putLong(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_FLOAT) {
						float sample = (float) 0.0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (float) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (float) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (float) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (float) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (float) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (float) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (float) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putFloat(sample);
						}
					} else if (data_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						double sample = 0.0;
						for (int i=0; i<numSamples; ++i) {
							if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
								sample = (double) i;
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
								sample = (double) (scalingOffset_B + i*scalingFactor_B);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_SHORT) {
								sample = (double) (scalingOffset_S + i*scalingFactor_S);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_INT) {
								sample = (double) (scalingOffset_I + i*scalingFactor_I);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_LONG) {
								sample = (double) (scalingOffset_L + i*scalingFactor_L);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_FLOAT) {
								sample = (double) (scalingOffset_F + i*scalingFactor_F);
							} else if (scaling_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
								sample = (double) (scalingOffset_D + i*scalingFactor_D);
							}
							referenceTarget.putDouble(sample);
						}
					}
					assertEquals(filesize, referenceTarget.position());
				}
			}
		}
	}
	
	// block comment headers are:
	// - index of test
	// - data type of time expression
	// - data type of scaling parameters
	// - data type of raw data
	
	/***********************************
	 * AUTO-GENERATED CODE STARTS HERE *
	 ***********************************/
	
	// L_N_B
	@Test
	public void testBuiltTimebase_L() {
		final int numSamples = 10;
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;
		
		// 'manually' build reference time stamps
		final long[] timebase = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			timebase[i] = t0_L + i*dt_L;
		}
		final long[] timebase_subset = new long[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);
		
		// no sourceOffset and targetOffset given
		final long[] targetTimebase = new long[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_L, dt_L);
		assertArrayEquals(timebase, targetTimebase);
		
		// sourceOffset and targetOffset are given
		final long[] targetTimebase_subset = new long[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_L, dt_L);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_L() {
		final long t0_L  = (long) 13.0;
		final long dt_L  = (long) 37.0;
		final long t_l_L = (long) 80.0;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_L, dt_L, t_l_L));
	}

	@Test
	public void testLastIndexInside_L() {
		final long t0_L  = (long) 13.0;
		final long dt_L  = (long) 37.0;
		final long t_u_L = (long) 300.0;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_L, dt_L, t_u_L));
	}

	@Test
	public void testFileOffset_B() {
		assertEquals(74, BinaryTimeseries.fileOffset(1, 10));
	}

	@Test
	public void testWriting_L_N_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
			(byte) 0x08, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_B, targetArr);
	}

	@Test
	public void testReading_L_N_B() {
	}

	// L_N_S
	@Test
	public void testFileOffset_S() {
		assertEquals(84, BinaryTimeseries.fileOffset(2, 10));
	}

	@Test
	public void testWriting_L_N_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_S, targetArr);
	}

	@Test
	public void testReading_L_N_S() {
	}

	// L_N_I
	@Test
	public void testFileOffset_I() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	@Test
	public void testWriting_L_N_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_I, targetArr);
	}

	@Test
	public void testReading_L_N_I() {
	}

	// L_N_L
	@Test
	public void testFileOffset_L() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	@Test
	public void testWriting_L_N_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_L_N_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_L, targetArr);
	}

	@Test
	public void testReading_L_N_L() {
	}

	// L_N_F
	@Test
	public void testFileOffset_F() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	@Test
	public void testWriting_L_N_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x40, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xA0, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xE0, (byte) 0x00, (byte) 0x00,
			(byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x10, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_N_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_F, targetArr);
	}

	@Test
	public void testReading_L_N_F() {
	}

	// L_N_D
	@Test
	public void testFileOffset_D() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	@Test
	public void testWriting_L_N_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_N_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x14, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x1C, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x22, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_N_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values);
		assertArrayEquals(referenceBTS_L_N_D, targetArr);
	}

	@Test
	public void testReading_L_N_D() {
	}

	// L_B_B
	@Test
	public void testWriting_L_B_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_B, targetArr);
	}

	@Test
	public void testReading_L_B_B() {
	}

	// L_B_S
	@Test
	public void testWriting_L_B_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_S, targetArr);
	}

	@Test
	public void testReading_L_B_S() {
	}

	// L_B_I
	@Test
	public void testWriting_L_B_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_I, targetArr);
	}

	@Test
	public void testReading_L_B_I() {
	}

	// L_B_L
	@Test
	public void testWriting_L_B_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_B_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_L, targetArr);
	}

	@Test
	public void testReading_L_B_L() {
	}

	// L_B_F
	@Test
	public void testWriting_L_B_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_B_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_F, targetArr);
	}

	@Test
	public void testReading_L_B_F() {
	}

	// L_B_D
	@Test
	public void testWriting_L_B_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_B_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_B_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_L_B_D, targetArr);
	}

	@Test
	public void testReading_L_B_D() {
	}

	// L_S_B
	@Test
	public void testWriting_L_S_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_B, targetArr);
	}

	@Test
	public void testReading_L_S_B() {
	}

	// L_S_S
	@Test
	public void testWriting_L_S_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_S, targetArr);
	}

	@Test
	public void testReading_L_S_S() {
	}

	// L_S_I
	@Test
	public void testWriting_L_S_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_I, targetArr);
	}

	@Test
	public void testReading_L_S_I() {
	}

	// L_S_L
	@Test
	public void testWriting_L_S_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_S_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_L, targetArr);
	}

	@Test
	public void testReading_L_S_L() {
	}

	// L_S_F
	@Test
	public void testWriting_L_S_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_S_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_F, targetArr);
	}

	@Test
	public void testReading_L_S_F() {
	}

	// L_S_D
	@Test
	public void testWriting_L_S_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_S_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_S_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_L_S_D, targetArr);
	}

	@Test
	public void testReading_L_S_D() {
	}

	// L_I_B
	@Test
	public void testWriting_L_I_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_B, targetArr);
	}

	@Test
	public void testReading_L_I_B() {
	}

	// L_I_S
	@Test
	public void testWriting_L_I_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_S, targetArr);
	}

	@Test
	public void testReading_L_I_S() {
	}

	// L_I_I
	@Test
	public void testWriting_L_I_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_I, targetArr);
	}

	@Test
	public void testReading_L_I_I() {
	}

	// L_I_L
	@Test
	public void testWriting_L_I_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_I_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_L, targetArr);
	}

	@Test
	public void testReading_L_I_L() {
	}

	// L_I_F
	@Test
	public void testWriting_L_I_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_I_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_F, targetArr);
	}

	@Test
	public void testReading_L_I_F() {
	}

	// L_I_D
	@Test
	public void testWriting_L_I_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_I_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_I_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_L_I_D, targetArr);
	}

	@Test
	public void testReading_L_I_D() {
	}

	// L_L_B
	@Test
	public void testWriting_L_L_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_B, targetArr);
	}

	@Test
	public void testReading_L_L_B() {
	}

	// L_L_S
	@Test
	public void testWriting_L_L_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_S, targetArr);
	}

	@Test
	public void testReading_L_L_S() {
	}

	// L_L_I
	@Test
	public void testWriting_L_L_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_I, targetArr);
	}

	@Test
	public void testReading_L_L_I() {
	}

	// L_L_L
	@Test
	public void testWriting_L_L_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_L_L_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_L, targetArr);
	}

	@Test
	public void testReading_L_L_L() {
	}

	// L_L_F
	@Test
	public void testWriting_L_L_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_L_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_F, targetArr);
	}

	@Test
	public void testReading_L_L_F() {
	}

	// L_L_D
	@Test
	public void testWriting_L_L_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_L_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_L_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_L_L_D, targetArr);
	}

	@Test
	public void testReading_L_L_D() {
	}

	// L_F_B
	@Test
	public void testWriting_L_F_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62, (byte) 0x7A, (byte) 0x92, (byte) 0xAB,
			(byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_B, targetArr);
	}

	@Test
	public void testReading_L_F_B() {
	}

	// L_F_S
	@Test
	public void testWriting_L_F_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_S, targetArr);
	}

	@Test
	public void testReading_L_F_S() {
	}

	// L_F_I
	@Test
	public void testWriting_L_F_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_I, targetArr);
	}

	@Test
	public void testReading_L_F_I() {
	}

	// L_F_L
	@Test
	public void testWriting_L_F_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_F_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_L, targetArr);
	}

	@Test
	public void testReading_L_F_L() {
	}

	// L_F_F
	@Test
	public void testWriting_L_F_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41, (byte) 0xCC, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0x94, (byte) 0x33, (byte) 0x32,
			(byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCC, (byte) 0x42, (byte) 0xF5, (byte) 0x66, (byte) 0x66,
			(byte) 0x43, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0x43, (byte) 0x2B, (byte) 0x4C, (byte) 0xCC,
			(byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x99, (byte) 0x43, (byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_L_F_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_F, targetArr);
	}

	@Test
	public void testReading_L_F_F() {
	}

	// L_F_D
	@Test
	public void testWriting_L_F_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_F_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x60, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x5F, (byte) 0xFF, (byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_L_F_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_L_F_D, targetArr);
	}

	@Test
	public void testReading_L_F_D() {
	}

	// L_D_B
	@Test
	public void testWriting_L_D_B() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62, (byte) 0x7A, (byte) 0x93, (byte) 0xAB,
			(byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_B, targetArr);
	}

	@Test
	public void testReading_L_D_B() {
	}

	// L_D_S
	@Test
	public void testWriting_L_D_S() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_S, targetArr);
	}

	@Test
	public void testReading_L_D_S() {
	}

	// L_D_I
	@Test
	public void testWriting_L_D_I() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_I, targetArr);
	}

	@Test
	public void testReading_L_D_I() {
	}

	// L_D_L
	@Test
	public void testWriting_L_D_L() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_L_D_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_L, targetArr);
	}

	@Test
	public void testReading_L_D_L() {
	}

	// L_D_F
	@Test
	public void testWriting_L_D_F() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41, (byte) 0xCC, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0x94, (byte) 0x33, (byte) 0x33,
			(byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCD, (byte) 0x42, (byte) 0xF5, (byte) 0x66, (byte) 0x66,
			(byte) 0x43, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x2B, (byte) 0x4C, (byte) 0xCD,
			(byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x9A, (byte) 0x43, (byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_L_D_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_F, targetArr);
	}

	@Test
	public void testReading_L_D_F() {
	}

	// L_D_D
	@Test
	public void testWriting_L_D_D() {
		final long t0_L = (long) 13.0;
		final long dt_L = (long) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_L, dt_L);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_L_D_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x0D, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x25, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33,
			(byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x67,
			(byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x67,
			(byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD,
			(byte) 0x40, (byte) 0x62, (byte) 0x60, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99,
			(byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33,
			(byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD };
		assertArrayEquals(referenceBTS_L_D_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_L, dt_L, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_L_D_D, targetArr);
	}

	@Test
	public void testReading_L_D_D() {
	}

	// D_N_B
	@Test
	public void testBuiltTimebase_D() {
		final int numSamples = 10;
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;
		
		// 'manually' build reference time stamps
		final double[] timebase = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			timebase[i] = t0_D + i*dt_D;
		}
		final double[] timebase_subset = new double[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);
		
		// no sourceOffset and targetOffset given
		final double[] targetTimebase = new double[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_D, dt_D);
		assertArrayEquals(timebase, targetTimebase);
		
		// sourceOffset and targetOffset are given
		final double[] targetTimebase_subset = new double[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_D, dt_D);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_D() {
		final double t0_D  = (double) 13.0;
		final double dt_D  = (double) 37.0;
		final double t_l_D = (double) 80.0;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_D, dt_D, t_l_D));
	}

	@Test
	public void testLastIndexInside_D() {
		final double t0_D  = (double) 13.0;
		final double dt_D  = (double) 37.0;
		final double t_u_D = (double) 300.0;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_D, dt_D, t_u_D));
	}

	@Test
	public void testWriting_D_N_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
			(byte) 0x08, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_B, targetArr);
	}

	@Test
	public void testReading_D_N_B() {
	}

	// D_N_S
	@Test
	public void testWriting_D_N_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_S, targetArr);
	}

	@Test
	public void testReading_D_N_S() {
	}

	// D_N_I
	@Test
	public void testWriting_D_N_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_I, targetArr);
	}

	@Test
	public void testReading_D_N_I() {
	}

	// D_N_L
	@Test
	public void testWriting_D_N_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x07,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09 };
		assertArrayEquals(referenceBTS_D_N_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_L, targetArr);
	}

	@Test
	public void testReading_D_N_L() {
	}

	// D_N_F
	@Test
	public void testWriting_D_N_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x40, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xA0, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0xE0, (byte) 0x00, (byte) 0x00,
			(byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x10, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_N_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_F, targetArr);
	}

	@Test
	public void testReading_D_N_F() {
	}

	// D_N_D
	@Test
	public void testWriting_D_N_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) i;
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScalingDisabled(target);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_N_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x14, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x1C, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x22, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_N_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values);
		assertArrayEquals(referenceBTS_D_N_D, targetArr);
	}

	@Test
	public void testReading_D_N_D() {
	}

	// D_B_B
	@Test
	public void testWriting_D_B_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_B, targetArr);
	}

	@Test
	public void testReading_D_B_B() {
	}

	// D_B_S
	@Test
	public void testWriting_D_B_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_S, targetArr);
	}

	@Test
	public void testReading_D_B_S() {
	}

	// D_B_I
	@Test
	public void testWriting_D_B_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_I, targetArr);
	}

	@Test
	public void testReading_D_B_I() {
	}

	// D_B_L
	@Test
	public void testWriting_D_B_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_B_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_L, targetArr);
	}

	@Test
	public void testReading_D_B_L() {
	}

	// D_B_F
	@Test
	public void testWriting_D_B_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_B_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_F, targetArr);
	}

	@Test
	public void testReading_D_B_F() {
	}

	// D_B_D
	@Test
	public void testWriting_D_B_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final byte scalingOffset_B = (byte) 1.2;
		final byte scalingFactor_B = (byte) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_B + i*scalingFactor_B);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_B, scalingFactor_B);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_B_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_B_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_B, scalingFactor_B);
		assertArrayEquals(referenceBTS_D_B_D, targetArr);
	}

	@Test
	public void testReading_D_B_D() {
	}

	// D_S_B
	@Test
	public void testWriting_D_S_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_B, targetArr);
	}

	@Test
	public void testReading_D_S_B() {
	}

	// D_S_S
	@Test
	public void testWriting_D_S_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_S, targetArr);
	}

	@Test
	public void testReading_D_S_S() {
	}

	// D_S_I
	@Test
	public void testWriting_D_S_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_I, targetArr);
	}

	@Test
	public void testReading_D_S_I() {
	}

	// D_S_L
	@Test
	public void testWriting_D_S_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_S_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_L, targetArr);
	}

	@Test
	public void testReading_D_S_L() {
	}

	// D_S_F
	@Test
	public void testWriting_D_S_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_S_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_F, targetArr);
	}

	@Test
	public void testReading_D_S_F() {
	}

	// D_S_D
	@Test
	public void testWriting_D_S_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final short scalingOffset_S = (short) 1.2;
		final short scalingFactor_S = (short) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_S + i*scalingFactor_S);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_S, scalingFactor_S);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_S_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_S_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_S, scalingFactor_S);
		assertArrayEquals(referenceBTS_D_S_D, targetArr);
	}

	@Test
	public void testReading_D_S_D() {
	}

	// D_I_B
	@Test
	public void testWriting_D_I_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_B, targetArr);
	}

	@Test
	public void testReading_D_I_B() {
	}

	// D_I_S
	@Test
	public void testWriting_D_I_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_S, targetArr);
	}

	@Test
	public void testReading_D_I_S() {
	}

	// D_I_I
	@Test
	public void testWriting_D_I_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_I, targetArr);
	}

	@Test
	public void testReading_D_I_I() {
	}

	// D_I_L
	@Test
	public void testWriting_D_I_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_I_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_L, targetArr);
	}

	@Test
	public void testReading_D_I_L() {
	}

	// D_I_F
	@Test
	public void testWriting_D_I_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_I_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_F, targetArr);
	}

	@Test
	public void testReading_D_I_F() {
	}

	// D_I_D
	@Test
	public void testWriting_D_I_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final int scalingOffset_I = (int) 1.2;
		final int scalingFactor_I = (int) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_I + i*scalingFactor_I);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_I, scalingFactor_I);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_I_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_I_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_I, scalingFactor_I);
		assertArrayEquals(referenceBTS_D_I_D, targetArr);
	}

	@Test
	public void testReading_D_I_D() {
	}

	// D_L_B
	@Test
	public void testWriting_D_L_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x49, (byte) 0x61, (byte) 0x79, (byte) 0x91, (byte) 0xA9,
			(byte) 0xC1, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_B, targetArr);
	}

	@Test
	public void testReading_D_L_B() {
	}

	// D_L_S
	@Test
	public void testWriting_D_L_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x79, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_S, targetArr);
	}

	@Test
	public void testReading_D_L_S() {
	}

	// D_L_I
	@Test
	public void testWriting_D_L_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_I, targetArr);
	}

	@Test
	public void testReading_D_L_I() {
	}

	// D_L_L
	@Test
	public void testWriting_D_L_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x49,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x61,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x79,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x91,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xA9,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC1,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD9 };
		assertArrayEquals(referenceBTS_D_L_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_L, targetArr);
	}

	@Test
	public void testReading_D_L_L() {
	}

	// D_L_F
	@Test
	public void testWriting_D_L_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC8, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x44, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0x92, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0xC2, (byte) 0x00, (byte) 0x00, (byte) 0x42, (byte) 0xF2, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x29, (byte) 0x00, (byte) 0x00,
			(byte) 0x43, (byte) 0x41, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x59, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_L_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_F, targetArr);
	}

	@Test
	public void testReading_D_L_F() {
	}

	// D_L_D
	@Test
	public void testWriting_D_L_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final long scalingOffset_L = (long) 1.2;
		final long scalingFactor_L = (long) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_L + i*scalingFactor_L);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_L, scalingFactor_L);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_L_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_L_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_L, scalingFactor_L);
		assertArrayEquals(referenceBTS_D_L_D, targetArr);
	}

	@Test
	public void testReading_D_L_D() {
	}

	// D_F_B
	@Test
	public void testWriting_D_F_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62, (byte) 0x7A, (byte) 0x92, (byte) 0xAB,
			(byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_B, targetArr);
	}

	@Test
	public void testReading_D_F_B() {
	}

	// D_F_S
	@Test
	public void testWriting_D_F_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_S, targetArr);
	}

	@Test
	public void testReading_D_F_S() {
	}

	// D_F_I
	@Test
	public void testWriting_D_F_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_I, targetArr);
	}

	@Test
	public void testReading_D_F_I() {
	}

	// D_F_L
	@Test
	public void testWriting_D_F_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x92,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_F_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_L, targetArr);
	}

	@Test
	public void testReading_D_F_L() {
	}

	// D_F_F
	@Test
	public void testWriting_D_F_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41, (byte) 0xCC, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0x94, (byte) 0x33, (byte) 0x32,
			(byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCC, (byte) 0x42, (byte) 0xF5, (byte) 0x66, (byte) 0x66,
			(byte) 0x43, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0x43, (byte) 0x2B, (byte) 0x4C, (byte) 0xCC,
			(byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x99, (byte) 0x43, (byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_D_F_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_F, targetArr);
	}

	@Test
	public void testReading_D_F_F() {
	}

	// D_F_D
	@Test
	public void testWriting_D_F_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final float scalingOffset_F = (float) 1.2;
		final float scalingFactor_F = (float) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_F + i*scalingFactor_F);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_F, scalingFactor_F);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_F_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xC2, (byte) 0x66, (byte) 0x66,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x60, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x62, (byte) 0x5F, (byte) 0xFF, (byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
		assertArrayEquals(referenceBTS_D_F_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_F, scalingFactor_F);
		assertArrayEquals(referenceBTS_D_F_D, targetArr);
	}

	@Test
	public void testReading_D_F_D() {
	}

	// D_D_B
	@Test
	public void testWriting_D_D_B() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final byte[] values = new byte[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (byte) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(1, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_B = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x01, (byte) 0x19, (byte) 0x31, (byte) 0x4A, (byte) 0x62, (byte) 0x7A, (byte) 0x93, (byte) 0xAB,
			(byte) 0xC3, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_B, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_B, targetArr);
	}

	@Test
	public void testReading_D_D_B() {
	}

	// D_D_S
	@Test
	public void testWriting_D_D_S() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final short[] values = new short[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (short) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(2, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_S = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x19, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x7A, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_S, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_S, targetArr);
	}

	@Test
	public void testReading_D_D_S() {
	}

	// D_D_I
	@Test
	public void testWriting_D_D_I() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final int[] values = new int[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (int) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_I = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_I, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_I, targetArr);
	}

	@Test
	public void testReading_D_D_I() {
	}

	// D_D_L
	@Test
	public void testWriting_D_D_L() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final long[] values = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (long) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_L = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x19,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x31,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x62,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7A,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x93,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xAB,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xC3,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xDB };
		assertArrayEquals(referenceBTS_D_D_L, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_L, targetArr);
	}

	@Test
	public void testReading_D_D_L() {
	}

	// D_D_F
	@Test
	public void testWriting_D_D_F() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final float[] values = new float[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (float) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(4, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_F = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0x99, (byte) 0x99, (byte) 0x9A, (byte) 0x41, (byte) 0xCC, (byte) 0x00, (byte) 0x00,
			(byte) 0x42, (byte) 0x47, (byte) 0x33, (byte) 0x33, (byte) 0x42, (byte) 0x94, (byte) 0x33, (byte) 0x33,
			(byte) 0x42, (byte) 0xC4, (byte) 0xCC, (byte) 0xCD, (byte) 0x42, (byte) 0xF5, (byte) 0x66, (byte) 0x66,
			(byte) 0x43, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x43, (byte) 0x2B, (byte) 0x4C, (byte) 0xCD,
			(byte) 0x43, (byte) 0x43, (byte) 0x99, (byte) 0x9A, (byte) 0x43, (byte) 0x5B, (byte) 0xE6, (byte) 0x66 };
		assertArrayEquals(referenceBTS_D_D_F, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_F, targetArr);
	}

	@Test
	public void testReading_D_D_F() {
	}

	// D_D_D
	@Test
	public void testWriting_D_D_D() {
		final double t0_D = (double) 13.0;
		final double dt_D = (double) 37.0;
		final double scalingOffset_D = (double) 1.2;
		final double scalingFactor_D = (double) 24.3;
		final int numSamples = 10;
		final double[] values = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			values[i] = (double) (scalingOffset_D + i*scalingFactor_D);
		}
		int fileSize = BinaryTimeseries.fileOffset(8, numSamples);
		final byte[] targetArr = new byte[fileSize];
		final ByteBuffer target = ByteBuffer.wrap(targetArr);
		BinaryTimeseries.writeEndianessCheckValue(target);
		BinaryTimeseries.writeTimebase(target, t0_D, dt_D);
		BinaryTimeseries.writeScaling(target, scalingOffset_D, scalingFactor_D);
		BinaryTimeseries.writeReservedDummy(target);
		BinaryTimeseries.writeData(target, values);
		final byte[] referenceBTS_D_D_D = new byte[] {
			(byte) 0x00, (byte) 0x01, (byte) 0x06, (byte) 0x40, (byte) 0x2A, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40, (byte) 0x42, (byte) 0x80, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33,
			(byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x40, (byte) 0x38, (byte) 0x4C, (byte) 0xCC,
			(byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A,
			(byte) 0x3F, (byte) 0xF3, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33,
			(byte) 0x40, (byte) 0x39, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x48, (byte) 0xE6, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x67,
			(byte) 0x40, (byte) 0x52, (byte) 0x86, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x66, (byte) 0x67,
			(byte) 0x40, (byte) 0x58, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x9A,
			(byte) 0x40, (byte) 0x5E, (byte) 0xAC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD,
			(byte) 0x40, (byte) 0x62, (byte) 0x60, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
			(byte) 0x40, (byte) 0x65, (byte) 0x69, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99, (byte) 0x99,
			(byte) 0x40, (byte) 0x68, (byte) 0x73, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x33,
			(byte) 0x40, (byte) 0x6B, (byte) 0x7C, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCC, (byte) 0xCD };
		assertArrayEquals(referenceBTS_D_D_D, targetArr);
		target.position(0);
		BinaryTimeseries.write(target, t0_D, dt_D, values, scalingOffset_D, scalingFactor_D);
		assertArrayEquals(referenceBTS_D_D_D, targetArr);
	}

	@Test
	public void testReading_D_D_D() {
	}





















	
	
	
	
	/***********************************
	 * AUTO-GENERATED CODE  ENDS  HERE *
	 ***********************************/
}
