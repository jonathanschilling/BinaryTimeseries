package de.labathome;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.nio.ByteBuffer;

import org.junit.jupiter.api.Test;

/**
 * The purpose of this test class is to check the full API of BinaryTimeseries for consistency.
 * The test code can be automagically generated by running the {@code main} method of this class.
 * 
 * @author Jonathan Schilling (jonathan.schilling@mail.de)
 */
public class ApiTests {

	/**
	 * Generate all test methods in this class and print the source code to the command line.
	 * @param args ignored
	 */
	public static void main(String[] args) {
		
		final byte[] time_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] scaling_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_NONE,
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final byte[] data_dtypes = new byte[] {
				BinaryTimeseries.DTYPE_BYTE,
				BinaryTimeseries.DTYPE_SHORT,
				BinaryTimeseries.DTYPE_INT,
				BinaryTimeseries.DTYPE_LONG,
				BinaryTimeseries.DTYPE_FLOAT,
				BinaryTimeseries.DTYPE_DOUBLE
		};
		
		final int[] data_sizes = new int[] {
				Byte.BYTES,
				Short.BYTES,
				Integer.BYTES,
				Long.BYTES,
				Float.BYTES,
				Double.BYTES
		};
		
		int numTests = 0;
		for (int time_dtype_idx=0; time_dtype_idx<time_dtypes.length; ++time_dtype_idx) {
			final byte time_dtype = time_dtypes[time_dtype_idx];
			
			for (int scaling_dtype_idx=0; scaling_dtype_idx<scaling_dtypes.length; ++scaling_dtype_idx) {
				final byte scaling_dtype = scaling_dtypes[scaling_dtype_idx];
				
				for (int data_dtype_idx=0; data_dtype_idx<data_dtypes.length; ++data_dtype_idx) {
					final byte data_dtype = data_dtypes[data_dtype_idx];
					final int data_size = data_sizes[data_dtype_idx];
					
					System.out.println(String.format("	// %2d ", numTests+1)+
							BinaryTimeseries.dtypeStr(   time_dtype)+" "+
							BinaryTimeseries.dtypeStr(scaling_dtype)+" "+
							BinaryTimeseries.dtypeStr(   data_dtype)
					);
					
					final int numSamples = 10;
					
					final   long t0_L = 13;
					final double t0_D = 13.0;
					
					final   long dt_L = 37;
					final double dt_D = 37.0;
					
					final   byte scalingOffset_B = (byte)  1.2;
					final  short scalingOffset_S = (short) 1.2;
					final    int scalingOffset_I = (int)   1.2;
					final   long scalingOffset_L = (long)  1.2;
					final  float scalingOffset_F = (float) 1.2;
					final double scalingOffset_D = (double)1.2;
					
					final   byte scalingFactor_B = (byte)  24.3;
					final  short scalingFactor_S = (short) 24.3;
					final    int scalingFactor_I = (int)   24.3;
					final   long scalingFactor_L = (long)  24.3;
					final  float scalingFactor_F = (float) 24.3;
					final double scalingFactor_D = (double)24.3;
					
					// time series:
					// idx | time  | value
					//   0 |  13.0 |   1.2
					//   1 |  50.0 |  25.5
					//   2 |  87.0 |  49.8
					//   3 | 124.0 |  74.1
					//   4 | 161.0 |  98.4
					//   5 | 198.0 | 122.7
					//   6 | 235.0 | 147.0
					//   7 | 272.0 | 171.3
					//   8 | 309.0 | 195.6
					//   9 | 346.0 | 219.9
					
					final int numSamplesSubset = 5;
					final int sourceOffset = 2;
					final int targetOffset = 0;
					
					final   long t_l_L = 80;   // => firstIndexInside = 2
					final double t_l_D = 80.0; // => firstIndexInside = 2
					
					final   long t_u_L = 300;   // => lastIndexInside = 7
					final double t_u_D = 300.0; // => lastIndexInside = 7
					
					// compute file size from reserved number of header bytes, sample size and number of samples
					final int filesize = 64 + data_size*numSamples;
					
					final byte[] binaryTimeseries = new byte[filesize];
					
					// check static routines
					if (scaling_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per time type
						
						// buildTimebase
						if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
							
							// testBuiltTimebase_L
							System.out.println("	@Test\n"+
									"	public void testBuiltTimebase_L() {\n"+
									"		final int numSamples = "+numSamples+";\n"+
									"		final long t0_L = "+t0_L+";\n"+
									"		final long dt_L = "+dt_L+";\n"+
									"		final int numSamplesSubset = "+numSamplesSubset+";\n"+
									"		final int sourceOffset = "+sourceOffset+";\n"+
									"		final int targetOffset = "+targetOffset+";\n"+
									"		\n"+
									"		// 'manually' build reference time stamps\n"+ 
									"		final long[] timebase = new long[numSamples];\n"+
									"		for (int i=0; i<numSamples; ++i) {\n"+
									"			timebase[i] = t0_L + i*dt_L;\n"+
									"		}\n"+
									"		final long[] timebase_subset = new long[numSamplesSubset];\n"+
									"		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);\n"+
									"		\n"+
									"		// no sourceOffset and targetOffset given\n"+
									"		final long[] targetTimebase = new long[numSamples];\n"+
									"		BinaryTimeseries.buildTimebase(targetTimebase, t0_L, dt_L);\n"+
									"		assertArrayEquals(timebase, targetTimebase);\n"+
									"		\n"+
									"		// sourceOffset and targetOffset are given\n"+
									"		final long[] targetTimebase_subset = new long[numSamplesSubset];\n"+
									"		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_L, dt_L);\n"+
									"		assertArrayEquals(timebase_subset, targetTimebase_subset);\n"+
									"	}\n");
							
							// testFirstIndexInside_L
							System.out.println("	@Test\n"+
									"	public void testFirstIndexInside_L() {\n"+
									"		final long t0_L  = "+t0_L+";\n"+
									"		final long dt_L  = "+dt_L+";\n"+
									"		final long t_l_L = "+t_l_L+";\n"+
									"		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_L, dt_L, t_l_L));\n"+
									"	}\n");
							
							// testLastIndexInside_L
							System.out.println("	@Test\n"+
									"	public void testLastIndexInside_L() {\n"+
									"		final long t0_L  = "+t0_L+";\n"+
									"		final long dt_L  = "+dt_L+";\n"+
									"		final long t_u_L = "+t_u_L+";\n"+
									"		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_L, dt_L, t_u_L));\n"+
									"	}\n");
							                                                                                                                                          
						} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
							System.out.println("	@Test\n"+
									"	public void testBuiltTimebase_D() {\n"+
									"		final int numSamples = "+numSamples+";\n"+
									"		final double t0_D = "+t0_D+";\n"+
									"		final double dt_D = "+dt_D+";\n"+
									"		final int numSamplesSubset = "+numSamplesSubset+";\n"+
									"		final int sourceOffset = "+sourceOffset+";\n"+
									"		final int targetOffset = "+targetOffset+";\n"+
									"		\n"+
									"		// 'manually' build reference time stamps\n"+ 
									"		final double[] timebase = new double[numSamples];\n"+
									"		for (int i=0; i<numSamples; ++i) {\n"+
									"			timebase[i] = t0_D + i*dt_D;\n"+
									"		}\n"+
									"		final double[] timebase_subset = new double[numSamplesSubset];\n"+
									"		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);\n"+
									"		\n"+
									"		// no sourceOffset and targetOffset given\n"+
									"		final double[] targetTimebase = new double[numSamples];\n"+
									"		BinaryTimeseries.buildTimebase(targetTimebase, t0_D, dt_D);\n"+
									"		assertArrayEquals(timebase, targetTimebase);\n"+
									"		\n"+
									"		// sourceOffset and targetOffset are given\n"+
									"		final double[] targetTimebase_subset = new double[numSamplesSubset];\n"+
									"		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_D, dt_D);\n"+
									"		assertArrayEquals(timebase_subset, targetTimebase_subset);\n"+
									"	}\n");
							
							// testFirstIndexInside_D
							System.out.println("	@Test\n"+
									"	public void testFirstIndexInside_D() {\n"+
									"		final double t0_D  = "+t0_D+";\n"+
									"		final double dt_D  = "+dt_D+";\n"+
									"		final double t_l_D = "+t_l_D+";\n"+
									"		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_D, dt_D, t_l_D));\n"+
									"	}\n");
							
							// testLastIndexInside_D
							System.out.println("	@Test\n"+
									"	public void testLastIndexInside_D() {\n"+
									"		final double t0_D  = "+t0_D+";\n"+
									"		final double dt_D  = "+dt_D+";\n"+
									"		final double t_u_D = "+t_u_D+";\n"+
									"		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_D, dt_D, t_u_D));\n"+
									"	}\n");
						}
					}
					
					if (time_dtype_idx == 0 && data_dtype_idx == 0) {
						// these need to be executed only once per scaling type
						
						
						
						
					}
					
					if (time_dtype_idx == 0 && scaling_dtype_idx == 0) {
						// these need to be executed only once per data type
						
						// fileOffset
						System.out.println("	@Test\n"+
								"	public void testFileOffset_"+BinaryTimeseries.dtypeStr(data_dtype)+"() {\n"+
								"		assertEquals("+filesize+", BinaryTimeseries.fileOffset("+data_size+", 10));\n"+
								"	}\n");
					}
					
					
					
					// 'manually' build a BinaryTimeseries
					final ByteBuffer target = ByteBuffer.wrap(binaryTimeseries);
					assertEquals(0, target.position());
					// endianess check short
					target.putShort((short)1);
					assertEquals(2, target.position());
					// dtype of time
					target.put(time_dtype);
					assertEquals(3, target.position());
					// t0
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						target.putLong(t0_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						target.putDouble(t0_D);
					}
					assertEquals(11, target.position());
					// dt
					if (time_dtype == BinaryTimeseries.DTYPE_LONG) {
						target.putLong(dt_L);
					} else if (time_dtype == BinaryTimeseries.DTYPE_DOUBLE) {
						target.putDouble(dt_D);
					}
					assertEquals(19, target.position());
					// scaling dtype
					target.put(scaling_dtype);
					assertEquals(20, target.position());
					if (scaling_dtype == BinaryTimeseries.DTYPE_NONE) {
						
					} else if (scaling_dtype == BinaryTimeseries.DTYPE_BYTE) {
						
					}
					
					// check writing routines
					
					
					
					
					// check reading routines
					
					
					numTests++;
				}
			}
			
		}
		
		System.out.println("	// total number of tests: "+numTests);
	}
	
	// block comment headers are:
	// - index of test
	// - data type of time expression
	// - data type of scaling parameters
	// - data type of raw data
	
	/***********************************
	 * AUTO-GENERATED CODE STARTS HERE *
	 ***********************************/
	
	//  1 L N B
	@Test
	public void testBuiltTimebase_L() {
		final int numSamples = 10;
		final long t0_L = 13;
		final long dt_L = 37;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;
		
		// 'manually' build reference time stamps
		final long[] timebase = new long[numSamples];
		for (int i=0; i<numSamples; ++i) {
			timebase[i] = t0_L + i*dt_L;
		}
		final long[] timebase_subset = new long[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);
		
		// no sourceOffset and targetOffset given
		final long[] targetTimebase = new long[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_L, dt_L);
		assertArrayEquals(timebase, targetTimebase);
		
		// sourceOffset and targetOffset are given
		final long[] targetTimebase_subset = new long[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_L, dt_L);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_L() {
		final long t0_L  = 13;
		final long dt_L  = 37;
		final long t_l_L = 80;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_L, dt_L, t_l_L));
	}

	@Test
	public void testLastIndexInside_L() {
		final long t0_L  = 13;
		final long dt_L  = 37;
		final long t_u_L = 300;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_L, dt_L, t_u_L));
	}

	@Test
	public void testFileOffset_B() {
		assertEquals(74, BinaryTimeseries.fileOffset(1, 10));
	}

	//  2 L N S
	@Test
	public void testFileOffset_S() {
		assertEquals(84, BinaryTimeseries.fileOffset(2, 10));
	}

	//  3 L N I
	@Test
	public void testFileOffset_I() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	//  4 L N L
	@Test
	public void testFileOffset_L() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	//  5 L N F
	@Test
	public void testFileOffset_F() {
		assertEquals(104, BinaryTimeseries.fileOffset(4, 10));
	}

	//  6 L N D
	@Test
	public void testFileOffset_D() {
		assertEquals(144, BinaryTimeseries.fileOffset(8, 10));
	}

	//  7 L B B
	//  8 L B S
	//  9 L B I
	// 10 L B L
	// 11 L B F
	// 12 L B D
	// 13 L S B
	// 14 L S S
	// 15 L S I
	// 16 L S L
	// 17 L S F
	// 18 L S D
	// 19 L I B
	// 20 L I S
	// 21 L I I
	// 22 L I L
	// 23 L I F
	// 24 L I D
	// 25 L L B
	// 26 L L S
	// 27 L L I
	// 28 L L L
	// 29 L L F
	// 30 L L D
	// 31 L F B
	// 32 L F S
	// 33 L F I
	// 34 L F L
	// 35 L F F
	// 36 L F D
	// 37 L D B
	// 38 L D S
	// 39 L D I
	// 40 L D L
	// 41 L D F
	// 42 L D D
	// 43 D N B
	@Test
	public void testBuiltTimebase_D() {
		final int numSamples = 10;
		final double t0_D = 13.0;
		final double dt_D = 37.0;
		final int numSamplesSubset = 5;
		final int sourceOffset = 2;
		final int targetOffset = 0;
		
		// 'manually' build reference time stamps
		final double[] timebase = new double[numSamples];
		for (int i=0; i<numSamples; ++i) {
			timebase[i] = t0_D + i*dt_D;
		}
		final double[] timebase_subset = new double[numSamplesSubset];
		System.arraycopy(timebase, sourceOffset, timebase_subset, targetOffset, numSamplesSubset);
		
		// no sourceOffset and targetOffset given
		final double[] targetTimebase = new double[numSamples];
		BinaryTimeseries.buildTimebase(targetTimebase, t0_D, dt_D);
		assertArrayEquals(timebase, targetTimebase);
		
		// sourceOffset and targetOffset are given
		final double[] targetTimebase_subset = new double[numSamplesSubset];
		BinaryTimeseries.buildTimebase(sourceOffset, targetTimebase_subset, targetOffset, numSamplesSubset, t0_D, dt_D);
		assertArrayEquals(timebase_subset, targetTimebase_subset);
	}

	@Test
	public void testFirstIndexInside_D() {
		final double t0_D  = 13.0;
		final double dt_D  = 37.0;
		final double t_l_D = 80.0;
		assertEquals(2, BinaryTimeseries.firstIndexInside(t0_D, dt_D, t_l_D));
	}

	@Test
	public void testLastIndexInside_D() {
		final double t0_D  = 13.0;
		final double dt_D  = 37.0;
		final double t_u_D = 300.0;
		assertEquals(7, BinaryTimeseries.lastIndexInside(t0_D, dt_D, t_u_D));
	}

	// 44 D N S
	// 45 D N I
	// 46 D N L
	// 47 D N F
	// 48 D N D
	// 49 D B B
	// 50 D B S
	// 51 D B I
	// 52 D B L
	// 53 D B F
	// 54 D B D
	// 55 D S B
	// 56 D S S
	// 57 D S I
	// 58 D S L
	// 59 D S F
	// 60 D S D
	// 61 D I B
	// 62 D I S
	// 63 D I I
	// 64 D I L
	// 65 D I F
	// 66 D I D
	// 67 D L B
	// 68 D L S
	// 69 D L I
	// 70 D L L
	// 71 D L F
	// 72 D L D
	// 73 D F B
	// 74 D F S
	// 75 D F I
	// 76 D F L
	// 77 D F F
	// 78 D F D
	// 79 D D B
	// 80 D D S
	// 81 D D I
	// 82 D D L
	// 83 D D F
	// 84 D D D
	// total number of tests: 84


	
	
	
	
	/***********************************
	 * AUTO-GENERATED CODE  ENDS  HERE *
	 ***********************************/
}
